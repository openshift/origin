// +build !ignore_autogenerated

// This file was autogenerated by conversion-gen. Do not edit it manually!

package v1

import (
	image_api "github.com/openshift/origin/pkg/image/api"
	api "k8s.io/kubernetes/pkg/api"
	api_v1 "k8s.io/kubernetes/pkg/api/v1"
	conversion "k8s.io/kubernetes/pkg/conversion"
	reflect "reflect"
)

func init() {
	if err := api.Scheme.AddGeneratedConversionFuncs(
		Convert_v1_DockerImageReference_To_api_DockerImageReference,
		Convert_api_DockerImageReference_To_v1_DockerImageReference,
		Convert_v1_Image_To_api_Image,
		Convert_api_Image_To_v1_Image,
		Convert_v1_ImageImportSpec_To_api_ImageImportSpec,
		Convert_api_ImageImportSpec_To_v1_ImageImportSpec,
		Convert_v1_ImageImportStatus_To_api_ImageImportStatus,
		Convert_api_ImageImportStatus_To_v1_ImageImportStatus,
		Convert_v1_ImageLayer_To_api_ImageLayer,
		Convert_api_ImageLayer_To_v1_ImageLayer,
		Convert_v1_ImageList_To_api_ImageList,
		Convert_api_ImageList_To_v1_ImageList,
		Convert_v1_ImageStream_To_api_ImageStream,
		Convert_api_ImageStream_To_v1_ImageStream,
		Convert_v1_ImageStreamImage_To_api_ImageStreamImage,
		Convert_api_ImageStreamImage_To_v1_ImageStreamImage,
		Convert_v1_ImageStreamImport_To_api_ImageStreamImport,
		Convert_api_ImageStreamImport_To_v1_ImageStreamImport,
		Convert_v1_ImageStreamImportSpec_To_api_ImageStreamImportSpec,
		Convert_api_ImageStreamImportSpec_To_v1_ImageStreamImportSpec,
		Convert_v1_ImageStreamImportStatus_To_api_ImageStreamImportStatus,
		Convert_api_ImageStreamImportStatus_To_v1_ImageStreamImportStatus,
		Convert_v1_ImageStreamList_To_api_ImageStreamList,
		Convert_api_ImageStreamList_To_v1_ImageStreamList,
		Convert_v1_ImageStreamMapping_To_api_ImageStreamMapping,
		Convert_api_ImageStreamMapping_To_v1_ImageStreamMapping,
		Convert_v1_ImageStreamSpec_To_api_ImageStreamSpec,
		Convert_api_ImageStreamSpec_To_v1_ImageStreamSpec,
		Convert_v1_ImageStreamStatus_To_api_ImageStreamStatus,
		Convert_api_ImageStreamStatus_To_v1_ImageStreamStatus,
		Convert_v1_ImageStreamTag_To_api_ImageStreamTag,
		Convert_api_ImageStreamTag_To_v1_ImageStreamTag,
		Convert_v1_ImageStreamTagList_To_api_ImageStreamTagList,
		Convert_api_ImageStreamTagList_To_v1_ImageStreamTagList,
		Convert_v1_RepositoryImportSpec_To_api_RepositoryImportSpec,
		Convert_api_RepositoryImportSpec_To_v1_RepositoryImportSpec,
		Convert_v1_RepositoryImportStatus_To_api_RepositoryImportStatus,
		Convert_api_RepositoryImportStatus_To_v1_RepositoryImportStatus,
		Convert_v1_TagEvent_To_api_TagEvent,
		Convert_api_TagEvent_To_v1_TagEvent,
		Convert_v1_TagEventCondition_To_api_TagEventCondition,
		Convert_api_TagEventCondition_To_v1_TagEventCondition,
		Convert_v1_TagImportPolicy_To_api_TagImportPolicy,
		Convert_api_TagImportPolicy_To_v1_TagImportPolicy,
		Convert_v1_TagReference_To_api_TagReference,
		Convert_api_TagReference_To_v1_TagReference,
	); err != nil {
		// if one of the conversion functions is malformed, detect it immediately.
		panic(err)
	}
}

func autoConvert_v1_DockerImageReference_To_api_DockerImageReference(in *DockerImageReference, out *image_api.DockerImageReference, s conversion.Scope) error {
	if defaulting, found := s.DefaultingInterface(reflect.TypeOf(*in)); found {
		defaulting.(func(*DockerImageReference))(in)
	}
	out.Registry = in.Registry
	out.Namespace = in.Namespace
	out.Name = in.Name
	out.Tag = in.Tag
	out.ID = in.ID
	return nil
}

func Convert_v1_DockerImageReference_To_api_DockerImageReference(in *DockerImageReference, out *image_api.DockerImageReference, s conversion.Scope) error {
	return autoConvert_v1_DockerImageReference_To_api_DockerImageReference(in, out, s)
}

func autoConvert_api_DockerImageReference_To_v1_DockerImageReference(in *image_api.DockerImageReference, out *DockerImageReference, s conversion.Scope) error {
	if defaulting, found := s.DefaultingInterface(reflect.TypeOf(*in)); found {
		defaulting.(func(*image_api.DockerImageReference))(in)
	}
	out.Registry = in.Registry
	out.Namespace = in.Namespace
	out.Name = in.Name
	out.Tag = in.Tag
	out.ID = in.ID
	return nil
}

func Convert_api_DockerImageReference_To_v1_DockerImageReference(in *image_api.DockerImageReference, out *DockerImageReference, s conversion.Scope) error {
	return autoConvert_api_DockerImageReference_To_v1_DockerImageReference(in, out, s)
}

func autoConvert_v1_ImageImportSpec_To_api_ImageImportSpec(in *ImageImportSpec, out *image_api.ImageImportSpec, s conversion.Scope) error {
	if defaulting, found := s.DefaultingInterface(reflect.TypeOf(*in)); found {
		defaulting.(func(*ImageImportSpec))(in)
	}
	// TODO: Inefficient conversion - can we improve it?
	if err := s.Convert(&in.From, &out.From, 0); err != nil {
		return err
	}
	if in.To != nil {
		in, out := &in.To, &out.To
		*out = new(api.LocalObjectReference)
		// TODO: Inefficient conversion - can we improve it?
		if err := s.Convert(*in, *out, 0); err != nil {
			return err
		}
	} else {
		out.To = nil
	}
	if err := Convert_v1_TagImportPolicy_To_api_TagImportPolicy(&in.ImportPolicy, &out.ImportPolicy, s); err != nil {
		return err
	}
	out.IncludeManifest = in.IncludeManifest
	return nil
}

func Convert_v1_ImageImportSpec_To_api_ImageImportSpec(in *ImageImportSpec, out *image_api.ImageImportSpec, s conversion.Scope) error {
	return autoConvert_v1_ImageImportSpec_To_api_ImageImportSpec(in, out, s)
}

func autoConvert_api_ImageImportSpec_To_v1_ImageImportSpec(in *image_api.ImageImportSpec, out *ImageImportSpec, s conversion.Scope) error {
	if defaulting, found := s.DefaultingInterface(reflect.TypeOf(*in)); found {
		defaulting.(func(*image_api.ImageImportSpec))(in)
	}
	// TODO: Inefficient conversion - can we improve it?
	if err := s.Convert(&in.From, &out.From, 0); err != nil {
		return err
	}
	if in.To != nil {
		in, out := &in.To, &out.To
		*out = new(api_v1.LocalObjectReference)
		// TODO: Inefficient conversion - can we improve it?
		if err := s.Convert(*in, *out, 0); err != nil {
			return err
		}
	} else {
		out.To = nil
	}
	if err := Convert_api_TagImportPolicy_To_v1_TagImportPolicy(&in.ImportPolicy, &out.ImportPolicy, s); err != nil {
		return err
	}
	out.IncludeManifest = in.IncludeManifest
	return nil
}

func Convert_api_ImageImportSpec_To_v1_ImageImportSpec(in *image_api.ImageImportSpec, out *ImageImportSpec, s conversion.Scope) error {
	return autoConvert_api_ImageImportSpec_To_v1_ImageImportSpec(in, out, s)
}

func autoConvert_v1_ImageImportStatus_To_api_ImageImportStatus(in *ImageImportStatus, out *image_api.ImageImportStatus, s conversion.Scope) error {
	if defaulting, found := s.DefaultingInterface(reflect.TypeOf(*in)); found {
		defaulting.(func(*ImageImportStatus))(in)
	}
	// TODO: Inefficient conversion - can we improve it?
	if err := s.Convert(&in.Status, &out.Status, 0); err != nil {
		return err
	}
	if in.Image != nil {
		in, out := &in.Image, &out.Image
		*out = new(image_api.Image)
		if err := Convert_v1_Image_To_api_Image(*in, *out, s); err != nil {
			return err
		}
	} else {
		out.Image = nil
	}
	out.Tag = in.Tag
	return nil
}

func Convert_v1_ImageImportStatus_To_api_ImageImportStatus(in *ImageImportStatus, out *image_api.ImageImportStatus, s conversion.Scope) error {
	return autoConvert_v1_ImageImportStatus_To_api_ImageImportStatus(in, out, s)
}

func autoConvert_api_ImageImportStatus_To_v1_ImageImportStatus(in *image_api.ImageImportStatus, out *ImageImportStatus, s conversion.Scope) error {
	if defaulting, found := s.DefaultingInterface(reflect.TypeOf(*in)); found {
		defaulting.(func(*image_api.ImageImportStatus))(in)
	}
	out.Tag = in.Tag
	// TODO: Inefficient conversion - can we improve it?
	if err := s.Convert(&in.Status, &out.Status, 0); err != nil {
		return err
	}
	if in.Image != nil {
		in, out := &in.Image, &out.Image
		*out = new(Image)
		if err := Convert_api_Image_To_v1_Image(*in, *out, s); err != nil {
			return err
		}
	} else {
		out.Image = nil
	}
	return nil
}

func Convert_api_ImageImportStatus_To_v1_ImageImportStatus(in *image_api.ImageImportStatus, out *ImageImportStatus, s conversion.Scope) error {
	return autoConvert_api_ImageImportStatus_To_v1_ImageImportStatus(in, out, s)
}

func autoConvert_v1_ImageLayer_To_api_ImageLayer(in *ImageLayer, out *image_api.ImageLayer, s conversion.Scope) error {
	if defaulting, found := s.DefaultingInterface(reflect.TypeOf(*in)); found {
		defaulting.(func(*ImageLayer))(in)
	}
	out.Name = in.Name
	out.Size = in.Size
	return nil
}

func Convert_v1_ImageLayer_To_api_ImageLayer(in *ImageLayer, out *image_api.ImageLayer, s conversion.Scope) error {
	return autoConvert_v1_ImageLayer_To_api_ImageLayer(in, out, s)
}

func autoConvert_api_ImageLayer_To_v1_ImageLayer(in *image_api.ImageLayer, out *ImageLayer, s conversion.Scope) error {
	if defaulting, found := s.DefaultingInterface(reflect.TypeOf(*in)); found {
		defaulting.(func(*image_api.ImageLayer))(in)
	}
	out.Name = in.Name
	out.Size = in.Size
	return nil
}

func Convert_api_ImageLayer_To_v1_ImageLayer(in *image_api.ImageLayer, out *ImageLayer, s conversion.Scope) error {
	return autoConvert_api_ImageLayer_To_v1_ImageLayer(in, out, s)
}

func autoConvert_v1_ImageList_To_api_ImageList(in *ImageList, out *image_api.ImageList, s conversion.Scope) error {
	if defaulting, found := s.DefaultingInterface(reflect.TypeOf(*in)); found {
		defaulting.(func(*ImageList))(in)
	}
	if err := api.Convert_unversioned_TypeMeta_To_unversioned_TypeMeta(&in.TypeMeta, &out.TypeMeta, s); err != nil {
		return err
	}
	if err := api.Convert_unversioned_ListMeta_To_unversioned_ListMeta(&in.ListMeta, &out.ListMeta, s); err != nil {
		return err
	}
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]image_api.Image, len(*in))
		for i := range *in {
			if err := Convert_v1_Image_To_api_Image(&(*in)[i], &(*out)[i], s); err != nil {
				return err
			}
		}
	} else {
		out.Items = nil
	}
	return nil
}

func Convert_v1_ImageList_To_api_ImageList(in *ImageList, out *image_api.ImageList, s conversion.Scope) error {
	return autoConvert_v1_ImageList_To_api_ImageList(in, out, s)
}

func autoConvert_api_ImageList_To_v1_ImageList(in *image_api.ImageList, out *ImageList, s conversion.Scope) error {
	if defaulting, found := s.DefaultingInterface(reflect.TypeOf(*in)); found {
		defaulting.(func(*image_api.ImageList))(in)
	}
	if err := api.Convert_unversioned_TypeMeta_To_unversioned_TypeMeta(&in.TypeMeta, &out.TypeMeta, s); err != nil {
		return err
	}
	if err := api.Convert_unversioned_ListMeta_To_unversioned_ListMeta(&in.ListMeta, &out.ListMeta, s); err != nil {
		return err
	}
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]Image, len(*in))
		for i := range *in {
			if err := Convert_api_Image_To_v1_Image(&(*in)[i], &(*out)[i], s); err != nil {
				return err
			}
		}
	} else {
		out.Items = nil
	}
	return nil
}

func Convert_api_ImageList_To_v1_ImageList(in *image_api.ImageList, out *ImageList, s conversion.Scope) error {
	return autoConvert_api_ImageList_To_v1_ImageList(in, out, s)
}

func autoConvert_v1_ImageStream_To_api_ImageStream(in *ImageStream, out *image_api.ImageStream, s conversion.Scope) error {
	if defaulting, found := s.DefaultingInterface(reflect.TypeOf(*in)); found {
		defaulting.(func(*ImageStream))(in)
	}
	if err := api.Convert_unversioned_TypeMeta_To_unversioned_TypeMeta(&in.TypeMeta, &out.TypeMeta, s); err != nil {
		return err
	}
	// TODO: Inefficient conversion - can we improve it?
	if err := s.Convert(&in.ObjectMeta, &out.ObjectMeta, 0); err != nil {
		return err
	}
	if err := Convert_v1_ImageStreamSpec_To_api_ImageStreamSpec(&in.Spec, &out.Spec, s); err != nil {
		return err
	}
	if err := Convert_v1_ImageStreamStatus_To_api_ImageStreamStatus(&in.Status, &out.Status, s); err != nil {
		return err
	}
	return nil
}

func Convert_v1_ImageStream_To_api_ImageStream(in *ImageStream, out *image_api.ImageStream, s conversion.Scope) error {
	return autoConvert_v1_ImageStream_To_api_ImageStream(in, out, s)
}

func autoConvert_api_ImageStream_To_v1_ImageStream(in *image_api.ImageStream, out *ImageStream, s conversion.Scope) error {
	if defaulting, found := s.DefaultingInterface(reflect.TypeOf(*in)); found {
		defaulting.(func(*image_api.ImageStream))(in)
	}
	if err := api.Convert_unversioned_TypeMeta_To_unversioned_TypeMeta(&in.TypeMeta, &out.TypeMeta, s); err != nil {
		return err
	}
	// TODO: Inefficient conversion - can we improve it?
	if err := s.Convert(&in.ObjectMeta, &out.ObjectMeta, 0); err != nil {
		return err
	}
	if err := Convert_api_ImageStreamSpec_To_v1_ImageStreamSpec(&in.Spec, &out.Spec, s); err != nil {
		return err
	}
	if err := Convert_api_ImageStreamStatus_To_v1_ImageStreamStatus(&in.Status, &out.Status, s); err != nil {
		return err
	}
	return nil
}

func Convert_api_ImageStream_To_v1_ImageStream(in *image_api.ImageStream, out *ImageStream, s conversion.Scope) error {
	return autoConvert_api_ImageStream_To_v1_ImageStream(in, out, s)
}

func autoConvert_v1_ImageStreamImage_To_api_ImageStreamImage(in *ImageStreamImage, out *image_api.ImageStreamImage, s conversion.Scope) error {
	if defaulting, found := s.DefaultingInterface(reflect.TypeOf(*in)); found {
		defaulting.(func(*ImageStreamImage))(in)
	}
	if err := api.Convert_unversioned_TypeMeta_To_unversioned_TypeMeta(&in.TypeMeta, &out.TypeMeta, s); err != nil {
		return err
	}
	// TODO: Inefficient conversion - can we improve it?
	if err := s.Convert(&in.ObjectMeta, &out.ObjectMeta, 0); err != nil {
		return err
	}
	if err := Convert_v1_Image_To_api_Image(&in.Image, &out.Image, s); err != nil {
		return err
	}
	return nil
}

func Convert_v1_ImageStreamImage_To_api_ImageStreamImage(in *ImageStreamImage, out *image_api.ImageStreamImage, s conversion.Scope) error {
	return autoConvert_v1_ImageStreamImage_To_api_ImageStreamImage(in, out, s)
}

func autoConvert_api_ImageStreamImage_To_v1_ImageStreamImage(in *image_api.ImageStreamImage, out *ImageStreamImage, s conversion.Scope) error {
	if defaulting, found := s.DefaultingInterface(reflect.TypeOf(*in)); found {
		defaulting.(func(*image_api.ImageStreamImage))(in)
	}
	if err := api.Convert_unversioned_TypeMeta_To_unversioned_TypeMeta(&in.TypeMeta, &out.TypeMeta, s); err != nil {
		return err
	}
	// TODO: Inefficient conversion - can we improve it?
	if err := s.Convert(&in.ObjectMeta, &out.ObjectMeta, 0); err != nil {
		return err
	}
	if err := Convert_api_Image_To_v1_Image(&in.Image, &out.Image, s); err != nil {
		return err
	}
	return nil
}

func Convert_api_ImageStreamImage_To_v1_ImageStreamImage(in *image_api.ImageStreamImage, out *ImageStreamImage, s conversion.Scope) error {
	return autoConvert_api_ImageStreamImage_To_v1_ImageStreamImage(in, out, s)
}

func autoConvert_v1_ImageStreamImport_To_api_ImageStreamImport(in *ImageStreamImport, out *image_api.ImageStreamImport, s conversion.Scope) error {
	if defaulting, found := s.DefaultingInterface(reflect.TypeOf(*in)); found {
		defaulting.(func(*ImageStreamImport))(in)
	}
	if err := api.Convert_unversioned_TypeMeta_To_unversioned_TypeMeta(&in.TypeMeta, &out.TypeMeta, s); err != nil {
		return err
	}
	// TODO: Inefficient conversion - can we improve it?
	if err := s.Convert(&in.ObjectMeta, &out.ObjectMeta, 0); err != nil {
		return err
	}
	if err := Convert_v1_ImageStreamImportSpec_To_api_ImageStreamImportSpec(&in.Spec, &out.Spec, s); err != nil {
		return err
	}
	if err := Convert_v1_ImageStreamImportStatus_To_api_ImageStreamImportStatus(&in.Status, &out.Status, s); err != nil {
		return err
	}
	return nil
}

func Convert_v1_ImageStreamImport_To_api_ImageStreamImport(in *ImageStreamImport, out *image_api.ImageStreamImport, s conversion.Scope) error {
	return autoConvert_v1_ImageStreamImport_To_api_ImageStreamImport(in, out, s)
}

func autoConvert_api_ImageStreamImport_To_v1_ImageStreamImport(in *image_api.ImageStreamImport, out *ImageStreamImport, s conversion.Scope) error {
	if defaulting, found := s.DefaultingInterface(reflect.TypeOf(*in)); found {
		defaulting.(func(*image_api.ImageStreamImport))(in)
	}
	if err := api.Convert_unversioned_TypeMeta_To_unversioned_TypeMeta(&in.TypeMeta, &out.TypeMeta, s); err != nil {
		return err
	}
	// TODO: Inefficient conversion - can we improve it?
	if err := s.Convert(&in.ObjectMeta, &out.ObjectMeta, 0); err != nil {
		return err
	}
	if err := Convert_api_ImageStreamImportSpec_To_v1_ImageStreamImportSpec(&in.Spec, &out.Spec, s); err != nil {
		return err
	}
	if err := Convert_api_ImageStreamImportStatus_To_v1_ImageStreamImportStatus(&in.Status, &out.Status, s); err != nil {
		return err
	}
	return nil
}

func Convert_api_ImageStreamImport_To_v1_ImageStreamImport(in *image_api.ImageStreamImport, out *ImageStreamImport, s conversion.Scope) error {
	return autoConvert_api_ImageStreamImport_To_v1_ImageStreamImport(in, out, s)
}

func autoConvert_v1_ImageStreamImportSpec_To_api_ImageStreamImportSpec(in *ImageStreamImportSpec, out *image_api.ImageStreamImportSpec, s conversion.Scope) error {
	if defaulting, found := s.DefaultingInterface(reflect.TypeOf(*in)); found {
		defaulting.(func(*ImageStreamImportSpec))(in)
	}
	out.Import = in.Import
	if in.Repository != nil {
		in, out := &in.Repository, &out.Repository
		*out = new(image_api.RepositoryImportSpec)
		if err := Convert_v1_RepositoryImportSpec_To_api_RepositoryImportSpec(*in, *out, s); err != nil {
			return err
		}
	} else {
		out.Repository = nil
	}
	if in.Images != nil {
		in, out := &in.Images, &out.Images
		*out = make([]image_api.ImageImportSpec, len(*in))
		for i := range *in {
			if err := Convert_v1_ImageImportSpec_To_api_ImageImportSpec(&(*in)[i], &(*out)[i], s); err != nil {
				return err
			}
		}
	} else {
		out.Images = nil
	}
	return nil
}

func Convert_v1_ImageStreamImportSpec_To_api_ImageStreamImportSpec(in *ImageStreamImportSpec, out *image_api.ImageStreamImportSpec, s conversion.Scope) error {
	return autoConvert_v1_ImageStreamImportSpec_To_api_ImageStreamImportSpec(in, out, s)
}

func autoConvert_api_ImageStreamImportSpec_To_v1_ImageStreamImportSpec(in *image_api.ImageStreamImportSpec, out *ImageStreamImportSpec, s conversion.Scope) error {
	if defaulting, found := s.DefaultingInterface(reflect.TypeOf(*in)); found {
		defaulting.(func(*image_api.ImageStreamImportSpec))(in)
	}
	out.Import = in.Import
	if in.Repository != nil {
		in, out := &in.Repository, &out.Repository
		*out = new(RepositoryImportSpec)
		if err := Convert_api_RepositoryImportSpec_To_v1_RepositoryImportSpec(*in, *out, s); err != nil {
			return err
		}
	} else {
		out.Repository = nil
	}
	if in.Images != nil {
		in, out := &in.Images, &out.Images
		*out = make([]ImageImportSpec, len(*in))
		for i := range *in {
			if err := Convert_api_ImageImportSpec_To_v1_ImageImportSpec(&(*in)[i], &(*out)[i], s); err != nil {
				return err
			}
		}
	} else {
		out.Images = nil
	}
	return nil
}

func Convert_api_ImageStreamImportSpec_To_v1_ImageStreamImportSpec(in *image_api.ImageStreamImportSpec, out *ImageStreamImportSpec, s conversion.Scope) error {
	return autoConvert_api_ImageStreamImportSpec_To_v1_ImageStreamImportSpec(in, out, s)
}

func autoConvert_v1_ImageStreamImportStatus_To_api_ImageStreamImportStatus(in *ImageStreamImportStatus, out *image_api.ImageStreamImportStatus, s conversion.Scope) error {
	if defaulting, found := s.DefaultingInterface(reflect.TypeOf(*in)); found {
		defaulting.(func(*ImageStreamImportStatus))(in)
	}
	if in.Import != nil {
		in, out := &in.Import, &out.Import
		*out = new(image_api.ImageStream)
		if err := Convert_v1_ImageStream_To_api_ImageStream(*in, *out, s); err != nil {
			return err
		}
	} else {
		out.Import = nil
	}
	if in.Repository != nil {
		in, out := &in.Repository, &out.Repository
		*out = new(image_api.RepositoryImportStatus)
		if err := Convert_v1_RepositoryImportStatus_To_api_RepositoryImportStatus(*in, *out, s); err != nil {
			return err
		}
	} else {
		out.Repository = nil
	}
	if in.Images != nil {
		in, out := &in.Images, &out.Images
		*out = make([]image_api.ImageImportStatus, len(*in))
		for i := range *in {
			if err := Convert_v1_ImageImportStatus_To_api_ImageImportStatus(&(*in)[i], &(*out)[i], s); err != nil {
				return err
			}
		}
	} else {
		out.Images = nil
	}
	return nil
}

func Convert_v1_ImageStreamImportStatus_To_api_ImageStreamImportStatus(in *ImageStreamImportStatus, out *image_api.ImageStreamImportStatus, s conversion.Scope) error {
	return autoConvert_v1_ImageStreamImportStatus_To_api_ImageStreamImportStatus(in, out, s)
}

func autoConvert_api_ImageStreamImportStatus_To_v1_ImageStreamImportStatus(in *image_api.ImageStreamImportStatus, out *ImageStreamImportStatus, s conversion.Scope) error {
	if defaulting, found := s.DefaultingInterface(reflect.TypeOf(*in)); found {
		defaulting.(func(*image_api.ImageStreamImportStatus))(in)
	}
	if in.Import != nil {
		in, out := &in.Import, &out.Import
		*out = new(ImageStream)
		if err := Convert_api_ImageStream_To_v1_ImageStream(*in, *out, s); err != nil {
			return err
		}
	} else {
		out.Import = nil
	}
	if in.Repository != nil {
		in, out := &in.Repository, &out.Repository
		*out = new(RepositoryImportStatus)
		if err := Convert_api_RepositoryImportStatus_To_v1_RepositoryImportStatus(*in, *out, s); err != nil {
			return err
		}
	} else {
		out.Repository = nil
	}
	if in.Images != nil {
		in, out := &in.Images, &out.Images
		*out = make([]ImageImportStatus, len(*in))
		for i := range *in {
			if err := Convert_api_ImageImportStatus_To_v1_ImageImportStatus(&(*in)[i], &(*out)[i], s); err != nil {
				return err
			}
		}
	} else {
		out.Images = nil
	}
	return nil
}

func Convert_api_ImageStreamImportStatus_To_v1_ImageStreamImportStatus(in *image_api.ImageStreamImportStatus, out *ImageStreamImportStatus, s conversion.Scope) error {
	return autoConvert_api_ImageStreamImportStatus_To_v1_ImageStreamImportStatus(in, out, s)
}

func autoConvert_v1_ImageStreamList_To_api_ImageStreamList(in *ImageStreamList, out *image_api.ImageStreamList, s conversion.Scope) error {
	if defaulting, found := s.DefaultingInterface(reflect.TypeOf(*in)); found {
		defaulting.(func(*ImageStreamList))(in)
	}
	if err := api.Convert_unversioned_TypeMeta_To_unversioned_TypeMeta(&in.TypeMeta, &out.TypeMeta, s); err != nil {
		return err
	}
	if err := api.Convert_unversioned_ListMeta_To_unversioned_ListMeta(&in.ListMeta, &out.ListMeta, s); err != nil {
		return err
	}
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]image_api.ImageStream, len(*in))
		for i := range *in {
			if err := Convert_v1_ImageStream_To_api_ImageStream(&(*in)[i], &(*out)[i], s); err != nil {
				return err
			}
		}
	} else {
		out.Items = nil
	}
	return nil
}

func Convert_v1_ImageStreamList_To_api_ImageStreamList(in *ImageStreamList, out *image_api.ImageStreamList, s conversion.Scope) error {
	return autoConvert_v1_ImageStreamList_To_api_ImageStreamList(in, out, s)
}

func autoConvert_api_ImageStreamList_To_v1_ImageStreamList(in *image_api.ImageStreamList, out *ImageStreamList, s conversion.Scope) error {
	if defaulting, found := s.DefaultingInterface(reflect.TypeOf(*in)); found {
		defaulting.(func(*image_api.ImageStreamList))(in)
	}
	if err := api.Convert_unversioned_TypeMeta_To_unversioned_TypeMeta(&in.TypeMeta, &out.TypeMeta, s); err != nil {
		return err
	}
	if err := api.Convert_unversioned_ListMeta_To_unversioned_ListMeta(&in.ListMeta, &out.ListMeta, s); err != nil {
		return err
	}
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]ImageStream, len(*in))
		for i := range *in {
			if err := Convert_api_ImageStream_To_v1_ImageStream(&(*in)[i], &(*out)[i], s); err != nil {
				return err
			}
		}
	} else {
		out.Items = nil
	}
	return nil
}

func Convert_api_ImageStreamList_To_v1_ImageStreamList(in *image_api.ImageStreamList, out *ImageStreamList, s conversion.Scope) error {
	return autoConvert_api_ImageStreamList_To_v1_ImageStreamList(in, out, s)
}

func autoConvert_v1_ImageStreamMapping_To_api_ImageStreamMapping(in *ImageStreamMapping, out *image_api.ImageStreamMapping, s conversion.Scope) error {
	if defaulting, found := s.DefaultingInterface(reflect.TypeOf(*in)); found {
		defaulting.(func(*ImageStreamMapping))(in)
	}
	if err := api.Convert_unversioned_TypeMeta_To_unversioned_TypeMeta(&in.TypeMeta, &out.TypeMeta, s); err != nil {
		return err
	}
	// TODO: Inefficient conversion - can we improve it?
	if err := s.Convert(&in.ObjectMeta, &out.ObjectMeta, 0); err != nil {
		return err
	}
	if err := Convert_v1_Image_To_api_Image(&in.Image, &out.Image, s); err != nil {
		return err
	}
	out.Tag = in.Tag
	return nil
}

func autoConvert_v1_ImageStreamTag_To_api_ImageStreamTag(in *ImageStreamTag, out *image_api.ImageStreamTag, s conversion.Scope) error {
	if defaulting, found := s.DefaultingInterface(reflect.TypeOf(*in)); found {
		defaulting.(func(*ImageStreamTag))(in)
	}
	if err := api.Convert_unversioned_TypeMeta_To_unversioned_TypeMeta(&in.TypeMeta, &out.TypeMeta, s); err != nil {
		return err
	}
	// TODO: Inefficient conversion - can we improve it?
	if err := s.Convert(&in.ObjectMeta, &out.ObjectMeta, 0); err != nil {
		return err
	}
	if in.Tag != nil {
		in, out := &in.Tag, &out.Tag
		*out = new(image_api.TagReference)
		if err := Convert_v1_TagReference_To_api_TagReference(*in, *out, s); err != nil {
			return err
		}
	} else {
		out.Tag = nil
	}
	out.Generation = in.Generation
	if in.Conditions != nil {
		in, out := &in.Conditions, &out.Conditions
		*out = make([]image_api.TagEventCondition, len(*in))
		for i := range *in {
			if err := Convert_v1_TagEventCondition_To_api_TagEventCondition(&(*in)[i], &(*out)[i], s); err != nil {
				return err
			}
		}
	} else {
		out.Conditions = nil
	}
	if err := Convert_v1_Image_To_api_Image(&in.Image, &out.Image, s); err != nil {
		return err
	}
	return nil
}

func Convert_v1_ImageStreamTag_To_api_ImageStreamTag(in *ImageStreamTag, out *image_api.ImageStreamTag, s conversion.Scope) error {
	return autoConvert_v1_ImageStreamTag_To_api_ImageStreamTag(in, out, s)
}

func autoConvert_api_ImageStreamTag_To_v1_ImageStreamTag(in *image_api.ImageStreamTag, out *ImageStreamTag, s conversion.Scope) error {
	if defaulting, found := s.DefaultingInterface(reflect.TypeOf(*in)); found {
		defaulting.(func(*image_api.ImageStreamTag))(in)
	}
	if err := api.Convert_unversioned_TypeMeta_To_unversioned_TypeMeta(&in.TypeMeta, &out.TypeMeta, s); err != nil {
		return err
	}
	// TODO: Inefficient conversion - can we improve it?
	if err := s.Convert(&in.ObjectMeta, &out.ObjectMeta, 0); err != nil {
		return err
	}
	if in.Tag != nil {
		in, out := &in.Tag, &out.Tag
		*out = new(TagReference)
		if err := Convert_api_TagReference_To_v1_TagReference(*in, *out, s); err != nil {
			return err
		}
	} else {
		out.Tag = nil
	}
	out.Generation = in.Generation
	if in.Conditions != nil {
		in, out := &in.Conditions, &out.Conditions
		*out = make([]TagEventCondition, len(*in))
		for i := range *in {
			if err := Convert_api_TagEventCondition_To_v1_TagEventCondition(&(*in)[i], &(*out)[i], s); err != nil {
				return err
			}
		}
	} else {
		out.Conditions = nil
	}
	if err := Convert_api_Image_To_v1_Image(&in.Image, &out.Image, s); err != nil {
		return err
	}
	return nil
}

func Convert_api_ImageStreamTag_To_v1_ImageStreamTag(in *image_api.ImageStreamTag, out *ImageStreamTag, s conversion.Scope) error {
	return autoConvert_api_ImageStreamTag_To_v1_ImageStreamTag(in, out, s)
}

func autoConvert_v1_ImageStreamTagList_To_api_ImageStreamTagList(in *ImageStreamTagList, out *image_api.ImageStreamTagList, s conversion.Scope) error {
	if defaulting, found := s.DefaultingInterface(reflect.TypeOf(*in)); found {
		defaulting.(func(*ImageStreamTagList))(in)
	}
	if err := api.Convert_unversioned_TypeMeta_To_unversioned_TypeMeta(&in.TypeMeta, &out.TypeMeta, s); err != nil {
		return err
	}
	if err := api.Convert_unversioned_ListMeta_To_unversioned_ListMeta(&in.ListMeta, &out.ListMeta, s); err != nil {
		return err
	}
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]image_api.ImageStreamTag, len(*in))
		for i := range *in {
			if err := Convert_v1_ImageStreamTag_To_api_ImageStreamTag(&(*in)[i], &(*out)[i], s); err != nil {
				return err
			}
		}
	} else {
		out.Items = nil
	}
	return nil
}

func Convert_v1_ImageStreamTagList_To_api_ImageStreamTagList(in *ImageStreamTagList, out *image_api.ImageStreamTagList, s conversion.Scope) error {
	return autoConvert_v1_ImageStreamTagList_To_api_ImageStreamTagList(in, out, s)
}

func autoConvert_api_ImageStreamTagList_To_v1_ImageStreamTagList(in *image_api.ImageStreamTagList, out *ImageStreamTagList, s conversion.Scope) error {
	if defaulting, found := s.DefaultingInterface(reflect.TypeOf(*in)); found {
		defaulting.(func(*image_api.ImageStreamTagList))(in)
	}
	if err := api.Convert_unversioned_TypeMeta_To_unversioned_TypeMeta(&in.TypeMeta, &out.TypeMeta, s); err != nil {
		return err
	}
	if err := api.Convert_unversioned_ListMeta_To_unversioned_ListMeta(&in.ListMeta, &out.ListMeta, s); err != nil {
		return err
	}
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]ImageStreamTag, len(*in))
		for i := range *in {
			if err := Convert_api_ImageStreamTag_To_v1_ImageStreamTag(&(*in)[i], &(*out)[i], s); err != nil {
				return err
			}
		}
	} else {
		out.Items = nil
	}
	return nil
}

func Convert_api_ImageStreamTagList_To_v1_ImageStreamTagList(in *image_api.ImageStreamTagList, out *ImageStreamTagList, s conversion.Scope) error {
	return autoConvert_api_ImageStreamTagList_To_v1_ImageStreamTagList(in, out, s)
}

func autoConvert_v1_RepositoryImportSpec_To_api_RepositoryImportSpec(in *RepositoryImportSpec, out *image_api.RepositoryImportSpec, s conversion.Scope) error {
	if defaulting, found := s.DefaultingInterface(reflect.TypeOf(*in)); found {
		defaulting.(func(*RepositoryImportSpec))(in)
	}
	// TODO: Inefficient conversion - can we improve it?
	if err := s.Convert(&in.From, &out.From, 0); err != nil {
		return err
	}
	if err := Convert_v1_TagImportPolicy_To_api_TagImportPolicy(&in.ImportPolicy, &out.ImportPolicy, s); err != nil {
		return err
	}
	out.IncludeManifest = in.IncludeManifest
	return nil
}

func Convert_v1_RepositoryImportSpec_To_api_RepositoryImportSpec(in *RepositoryImportSpec, out *image_api.RepositoryImportSpec, s conversion.Scope) error {
	return autoConvert_v1_RepositoryImportSpec_To_api_RepositoryImportSpec(in, out, s)
}

func autoConvert_api_RepositoryImportSpec_To_v1_RepositoryImportSpec(in *image_api.RepositoryImportSpec, out *RepositoryImportSpec, s conversion.Scope) error {
	if defaulting, found := s.DefaultingInterface(reflect.TypeOf(*in)); found {
		defaulting.(func(*image_api.RepositoryImportSpec))(in)
	}
	// TODO: Inefficient conversion - can we improve it?
	if err := s.Convert(&in.From, &out.From, 0); err != nil {
		return err
	}
	if err := Convert_api_TagImportPolicy_To_v1_TagImportPolicy(&in.ImportPolicy, &out.ImportPolicy, s); err != nil {
		return err
	}
	out.IncludeManifest = in.IncludeManifest
	return nil
}

func Convert_api_RepositoryImportSpec_To_v1_RepositoryImportSpec(in *image_api.RepositoryImportSpec, out *RepositoryImportSpec, s conversion.Scope) error {
	return autoConvert_api_RepositoryImportSpec_To_v1_RepositoryImportSpec(in, out, s)
}

func autoConvert_v1_RepositoryImportStatus_To_api_RepositoryImportStatus(in *RepositoryImportStatus, out *image_api.RepositoryImportStatus, s conversion.Scope) error {
	if defaulting, found := s.DefaultingInterface(reflect.TypeOf(*in)); found {
		defaulting.(func(*RepositoryImportStatus))(in)
	}
	// TODO: Inefficient conversion - can we improve it?
	if err := s.Convert(&in.Status, &out.Status, 0); err != nil {
		return err
	}
	if in.Images != nil {
		in, out := &in.Images, &out.Images
		*out = make([]image_api.ImageImportStatus, len(*in))
		for i := range *in {
			if err := Convert_v1_ImageImportStatus_To_api_ImageImportStatus(&(*in)[i], &(*out)[i], s); err != nil {
				return err
			}
		}
	} else {
		out.Images = nil
	}
	if in.AdditionalTags != nil {
		in, out := &in.AdditionalTags, &out.AdditionalTags
		*out = make([]string, len(*in))
		copy(*out, *in)
	} else {
		out.AdditionalTags = nil
	}
	return nil
}

func Convert_v1_RepositoryImportStatus_To_api_RepositoryImportStatus(in *RepositoryImportStatus, out *image_api.RepositoryImportStatus, s conversion.Scope) error {
	return autoConvert_v1_RepositoryImportStatus_To_api_RepositoryImportStatus(in, out, s)
}

func autoConvert_api_RepositoryImportStatus_To_v1_RepositoryImportStatus(in *image_api.RepositoryImportStatus, out *RepositoryImportStatus, s conversion.Scope) error {
	if defaulting, found := s.DefaultingInterface(reflect.TypeOf(*in)); found {
		defaulting.(func(*image_api.RepositoryImportStatus))(in)
	}
	// TODO: Inefficient conversion - can we improve it?
	if err := s.Convert(&in.Status, &out.Status, 0); err != nil {
		return err
	}
	if in.Images != nil {
		in, out := &in.Images, &out.Images
		*out = make([]ImageImportStatus, len(*in))
		for i := range *in {
			if err := Convert_api_ImageImportStatus_To_v1_ImageImportStatus(&(*in)[i], &(*out)[i], s); err != nil {
				return err
			}
		}
	} else {
		out.Images = nil
	}
	if in.AdditionalTags != nil {
		in, out := &in.AdditionalTags, &out.AdditionalTags
		*out = make([]string, len(*in))
		copy(*out, *in)
	} else {
		out.AdditionalTags = nil
	}
	return nil
}

func Convert_api_RepositoryImportStatus_To_v1_RepositoryImportStatus(in *image_api.RepositoryImportStatus, out *RepositoryImportStatus, s conversion.Scope) error {
	return autoConvert_api_RepositoryImportStatus_To_v1_RepositoryImportStatus(in, out, s)
}

func autoConvert_v1_TagEvent_To_api_TagEvent(in *TagEvent, out *image_api.TagEvent, s conversion.Scope) error {
	if defaulting, found := s.DefaultingInterface(reflect.TypeOf(*in)); found {
		defaulting.(func(*TagEvent))(in)
	}
	if err := api.Convert_unversioned_Time_To_unversioned_Time(&in.Created, &out.Created, s); err != nil {
		return err
	}
	out.DockerImageReference = in.DockerImageReference
	out.Image = in.Image
	out.Generation = in.Generation
	return nil
}

func Convert_v1_TagEvent_To_api_TagEvent(in *TagEvent, out *image_api.TagEvent, s conversion.Scope) error {
	return autoConvert_v1_TagEvent_To_api_TagEvent(in, out, s)
}

func autoConvert_api_TagEvent_To_v1_TagEvent(in *image_api.TagEvent, out *TagEvent, s conversion.Scope) error {
	if defaulting, found := s.DefaultingInterface(reflect.TypeOf(*in)); found {
		defaulting.(func(*image_api.TagEvent))(in)
	}
	if err := api.Convert_unversioned_Time_To_unversioned_Time(&in.Created, &out.Created, s); err != nil {
		return err
	}
	out.DockerImageReference = in.DockerImageReference
	out.Image = in.Image
	out.Generation = in.Generation
	return nil
}

func Convert_api_TagEvent_To_v1_TagEvent(in *image_api.TagEvent, out *TagEvent, s conversion.Scope) error {
	return autoConvert_api_TagEvent_To_v1_TagEvent(in, out, s)
}

func autoConvert_v1_TagEventCondition_To_api_TagEventCondition(in *TagEventCondition, out *image_api.TagEventCondition, s conversion.Scope) error {
	if defaulting, found := s.DefaultingInterface(reflect.TypeOf(*in)); found {
		defaulting.(func(*TagEventCondition))(in)
	}
	out.Type = image_api.TagEventConditionType(in.Type)
	out.Status = api.ConditionStatus(in.Status)
	if err := api.Convert_unversioned_Time_To_unversioned_Time(&in.LastTransitionTime, &out.LastTransitionTime, s); err != nil {
		return err
	}
	out.Reason = in.Reason
	out.Message = in.Message
	out.Generation = in.Generation
	return nil
}

func Convert_v1_TagEventCondition_To_api_TagEventCondition(in *TagEventCondition, out *image_api.TagEventCondition, s conversion.Scope) error {
	return autoConvert_v1_TagEventCondition_To_api_TagEventCondition(in, out, s)
}

func autoConvert_api_TagEventCondition_To_v1_TagEventCondition(in *image_api.TagEventCondition, out *TagEventCondition, s conversion.Scope) error {
	if defaulting, found := s.DefaultingInterface(reflect.TypeOf(*in)); found {
		defaulting.(func(*image_api.TagEventCondition))(in)
	}
	out.Type = TagEventConditionType(in.Type)
	out.Status = api_v1.ConditionStatus(in.Status)
	if err := api.Convert_unversioned_Time_To_unversioned_Time(&in.LastTransitionTime, &out.LastTransitionTime, s); err != nil {
		return err
	}
	out.Reason = in.Reason
	out.Message = in.Message
	out.Generation = in.Generation
	return nil
}

func Convert_api_TagEventCondition_To_v1_TagEventCondition(in *image_api.TagEventCondition, out *TagEventCondition, s conversion.Scope) error {
	return autoConvert_api_TagEventCondition_To_v1_TagEventCondition(in, out, s)
}

func autoConvert_v1_TagImportPolicy_To_api_TagImportPolicy(in *TagImportPolicy, out *image_api.TagImportPolicy, s conversion.Scope) error {
	if defaulting, found := s.DefaultingInterface(reflect.TypeOf(*in)); found {
		defaulting.(func(*TagImportPolicy))(in)
	}
	out.Insecure = in.Insecure
	out.Scheduled = in.Scheduled
	return nil
}

func Convert_v1_TagImportPolicy_To_api_TagImportPolicy(in *TagImportPolicy, out *image_api.TagImportPolicy, s conversion.Scope) error {
	return autoConvert_v1_TagImportPolicy_To_api_TagImportPolicy(in, out, s)
}

func autoConvert_api_TagImportPolicy_To_v1_TagImportPolicy(in *image_api.TagImportPolicy, out *TagImportPolicy, s conversion.Scope) error {
	if defaulting, found := s.DefaultingInterface(reflect.TypeOf(*in)); found {
		defaulting.(func(*image_api.TagImportPolicy))(in)
	}
	out.Insecure = in.Insecure
	out.Scheduled = in.Scheduled
	return nil
}

func Convert_api_TagImportPolicy_To_v1_TagImportPolicy(in *image_api.TagImportPolicy, out *TagImportPolicy, s conversion.Scope) error {
	return autoConvert_api_TagImportPolicy_To_v1_TagImportPolicy(in, out, s)
}

func autoConvert_v1_TagReference_To_api_TagReference(in *TagReference, out *image_api.TagReference, s conversion.Scope) error {
	if defaulting, found := s.DefaultingInterface(reflect.TypeOf(*in)); found {
		defaulting.(func(*TagReference))(in)
	}
	out.Name = in.Name
	if in.Annotations != nil {
		in, out := &in.Annotations, &out.Annotations
		*out = make(map[string]string, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	} else {
		out.Annotations = nil
	}
	if in.From != nil {
		in, out := &in.From, &out.From
		*out = new(api.ObjectReference)
		// TODO: Inefficient conversion - can we improve it?
		if err := s.Convert(*in, *out, 0); err != nil {
			return err
		}
	} else {
		out.From = nil
	}
	out.Reference = in.Reference
	if in.Generation != nil {
		in, out := &in.Generation, &out.Generation
		*out = new(int64)
		**out = **in
	} else {
		out.Generation = nil
	}
	if err := Convert_v1_TagImportPolicy_To_api_TagImportPolicy(&in.ImportPolicy, &out.ImportPolicy, s); err != nil {
		return err
	}
	return nil
}

func Convert_v1_TagReference_To_api_TagReference(in *TagReference, out *image_api.TagReference, s conversion.Scope) error {
	return autoConvert_v1_TagReference_To_api_TagReference(in, out, s)
}

func autoConvert_api_TagReference_To_v1_TagReference(in *image_api.TagReference, out *TagReference, s conversion.Scope) error {
	if defaulting, found := s.DefaultingInterface(reflect.TypeOf(*in)); found {
		defaulting.(func(*image_api.TagReference))(in)
	}
	out.Name = in.Name
	if in.Annotations != nil {
		in, out := &in.Annotations, &out.Annotations
		*out = make(map[string]string, len(*in))
		for key, val := range *in {
			(*out)[key] = val
		}
	} else {
		out.Annotations = nil
	}
	if in.From != nil {
		in, out := &in.From, &out.From
		*out = new(api_v1.ObjectReference)
		// TODO: Inefficient conversion - can we improve it?
		if err := s.Convert(*in, *out, 0); err != nil {
			return err
		}
	} else {
		out.From = nil
	}
	out.Reference = in.Reference
	if in.Generation != nil {
		in, out := &in.Generation, &out.Generation
		*out = new(int64)
		**out = **in
	} else {
		out.Generation = nil
	}
	if err := Convert_api_TagImportPolicy_To_v1_TagImportPolicy(&in.ImportPolicy, &out.ImportPolicy, s); err != nil {
		return err
	}
	return nil
}

func Convert_api_TagReference_To_v1_TagReference(in *image_api.TagReference, out *TagReference, s conversion.Scope) error {
	return autoConvert_api_TagReference_To_v1_TagReference(in, out, s)
}
