// Code generated by protoc-gen-go.
// source: api/filter/accesslog.proto
// DO NOT EDIT!

/*
Package filter is a generated protocol buffer package.

It is generated from these files:
	api/filter/accesslog.proto
	api/filter/fault.proto

It has these top-level messages:
	AccessLogEntry
	ComparisonFilter
	StatusCodeFilter
	DurationFilter
	NotHealthCheckFilter
	TraceableFilter
	RuntimeFilter
	AndFilter
	OrFilter
	AccessLogFilter
	FileAccessLog
	AccessLogServiceConfig
	StreamAccessLogsMessage
	StreamAccessLogsResponse
	AccessLog
	FaultDelay
*/
package filter

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import envoy_api_v21 "github.com/openshift/origin/pkg/router/envoy/api"
import google_protobuf1 "github.com/golang/protobuf/ptypes/duration"
import google_protobuf2 "github.com/golang/protobuf/ptypes/struct"
import google_protobuf3 "github.com/golang/protobuf/ptypes/timestamp"
import google_protobuf "github.com/golang/protobuf/ptypes/wrappers"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// Incoming protocol variation spoken
type AccessLogEntry_Protocol int32

const (
	AccessLogEntry_PROTOCOL_UNSPECIFIED AccessLogEntry_Protocol = 0
	AccessLogEntry_HTTP10               AccessLogEntry_Protocol = 1
	AccessLogEntry_HTTP11               AccessLogEntry_Protocol = 2
	AccessLogEntry_HTTP2                AccessLogEntry_Protocol = 3
)

var AccessLogEntry_Protocol_name = map[int32]string{
	0: "PROTOCOL_UNSPECIFIED",
	1: "HTTP10",
	2: "HTTP11",
	3: "HTTP2",
}
var AccessLogEntry_Protocol_value = map[string]int32{
	"PROTOCOL_UNSPECIFIED": 0,
	"HTTP10":               1,
	"HTTP11":               2,
	"HTTP2":                3,
}

func (x AccessLogEntry_Protocol) String() string {
	return proto.EnumName(AccessLogEntry_Protocol_name, int32(x))
}
func (AccessLogEntry_Protocol) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0, 0} }

// This enum defines the various things that may have occurred while
// processing a request.
type AccessLogEntry_ResponseFlag int32

const (
	// Local server healthcheck failed.
	AccessLogEntry_FAILED_LOCAL_HEALTHCHECK AccessLogEntry_ResponseFlag = 0
	// No healthy upstream.
	AccessLogEntry_NO_HEALTHY_UPSTREAM AccessLogEntry_ResponseFlag = 1
	// Request timeout on upstream.
	AccessLogEntry_UPSTREAM_REQUEST_TIMEOUT AccessLogEntry_ResponseFlag = 2
	// Local codec level reset was sent on the stream.
	AccessLogEntry_LOCAL_RESET AccessLogEntry_ResponseFlag = 3
	// Remote codec level reset was received on the stream.
	AccessLogEntry_UPSTREAM_REMOTE_RESET AccessLogEntry_ResponseFlag = 4
	// Local reset by a connection pool due to an initial connection failure.
	AccessLogEntry_UPSTREAM_CONNECTION_FAILURE AccessLogEntry_ResponseFlag = 5
	// If the stream was locally reset due to connection termination.
	AccessLogEntry_UPSTREAM_CONNECTION_TERMINATION AccessLogEntry_ResponseFlag = 6
	// The stream was reset because of a resource overflow.
	AccessLogEntry_UPSTREAM_OVERFLOW AccessLogEntry_ResponseFlag = 7
	// No route found for a given request.
	AccessLogEntry_NO_ROUTE_FOUND AccessLogEntry_ResponseFlag = 8
	// Request was delayed before proxying.
	AccessLogEntry_DELAY_INJECTED AccessLogEntry_ResponseFlag = 9
	// Abort with error code was injected.
	AccessLogEntry_FAULT_INJECTED AccessLogEntry_ResponseFlag = 10
	// Request was ratelimited locally by rate limit filter.
	AccessLogEntry_RATE_LIMITED AccessLogEntry_ResponseFlag = 11
)

var AccessLogEntry_ResponseFlag_name = map[int32]string{
	0:  "FAILED_LOCAL_HEALTHCHECK",
	1:  "NO_HEALTHY_UPSTREAM",
	2:  "UPSTREAM_REQUEST_TIMEOUT",
	3:  "LOCAL_RESET",
	4:  "UPSTREAM_REMOTE_RESET",
	5:  "UPSTREAM_CONNECTION_FAILURE",
	6:  "UPSTREAM_CONNECTION_TERMINATION",
	7:  "UPSTREAM_OVERFLOW",
	8:  "NO_ROUTE_FOUND",
	9:  "DELAY_INJECTED",
	10: "FAULT_INJECTED",
	11: "RATE_LIMITED",
}
var AccessLogEntry_ResponseFlag_value = map[string]int32{
	"FAILED_LOCAL_HEALTHCHECK":        0,
	"NO_HEALTHY_UPSTREAM":             1,
	"UPSTREAM_REQUEST_TIMEOUT":        2,
	"LOCAL_RESET":                     3,
	"UPSTREAM_REMOTE_RESET":           4,
	"UPSTREAM_CONNECTION_FAILURE":     5,
	"UPSTREAM_CONNECTION_TERMINATION": 6,
	"UPSTREAM_OVERFLOW":               7,
	"NO_ROUTE_FOUND":                  8,
	"DELAY_INJECTED":                  9,
	"FAULT_INJECTED":                  10,
	"RATE_LIMITED":                    11,
}

func (x AccessLogEntry_ResponseFlag) String() string {
	return proto.EnumName(AccessLogEntry_ResponseFlag_name, int32(x))
}
func (AccessLogEntry_ResponseFlag) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor0, []int{0, 1}
}

// TLS Version or VERSION_UNSPECIFIED if TLS was not used
type AccessLogEntry_TLSVersion int32

const (
	AccessLogEntry_VERSION_UNSPECIFIED AccessLogEntry_TLSVersion = 0
	AccessLogEntry_TLSv1               AccessLogEntry_TLSVersion = 1
	AccessLogEntry_TLSv1_1             AccessLogEntry_TLSVersion = 2
	AccessLogEntry_TLSv1_2             AccessLogEntry_TLSVersion = 3
	AccessLogEntry_TLSv1_3             AccessLogEntry_TLSVersion = 4
)

var AccessLogEntry_TLSVersion_name = map[int32]string{
	0: "VERSION_UNSPECIFIED",
	1: "TLSv1",
	2: "TLSv1_1",
	3: "TLSv1_2",
	4: "TLSv1_3",
}
var AccessLogEntry_TLSVersion_value = map[string]int32{
	"VERSION_UNSPECIFIED": 0,
	"TLSv1":               1,
	"TLSv1_1":             2,
	"TLSv1_2":             3,
	"TLSv1_3":             4,
}

func (x AccessLogEntry_TLSVersion) String() string {
	return proto.EnumName(AccessLogEntry_TLSVersion_name, int32(x))
}
func (AccessLogEntry_TLSVersion) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0, 2} }

// Comparison operator.
type ComparisonFilter_Op int32

const (
	ComparisonFilter_EQ ComparisonFilter_Op = 0
	ComparisonFilter_GE ComparisonFilter_Op = 1
)

var ComparisonFilter_Op_name = map[int32]string{
	0: "EQ",
	1: "GE",
}
var ComparisonFilter_Op_value = map[string]int32{
	"EQ": 0,
	"GE": 1,
}

func (x ComparisonFilter_Op) String() string {
	return proto.EnumName(ComparisonFilter_Op_name, int32(x))
}
func (ComparisonFilter_Op) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{1, 0} }

type AccessLogEntry struct {
	// The HTTP request method (RFC 7231/2616)
	RequestMethod envoy_api_v21.RequestMethod `protobuf:"varint,1,opt,name=request_method,json=requestMethod,enum=envoy.api.v2.RequestMethod" json:"request_method,omitempty"`
	// The time that Envoy started servicing this request
	StartTime       *google_protobuf3.Timestamp `protobuf:"bytes,2,opt,name=start_time,json=startTime" json:"start_time,omitempty"`
	ProtocolVariant AccessLogEntry_Protocol     `protobuf:"varint,3,opt,name=protocol_variant,json=protocolVariant,enum=envoy.api.v2.filter.AccessLogEntry_Protocol" json:"protocol_variant,omitempty"`
	// Status flags about the response.
	ResponseFlags []AccessLogEntry_ResponseFlag `protobuf:"varint,4,rep,packed,name=response_flags,json=responseFlags,enum=envoy.api.v2.filter.AccessLogEntry_ResponseFlag" json:"response_flags,omitempty"`
	// The upstream host URL (Envoy connects to).
	//
	// For example, tcp://ip:port for TCP connections.
	//
	// IPv6 addresses should be stored in canonical (compressed) format using
	// [address]:port notation.
	UpstreamHost string `protobuf:"bytes,5,opt,name=upstream_host,json=upstreamHost" json:"upstream_host,omitempty"`
	// The Upstream Cluster that the upstream host belongs to.
	UpstreamCluster string `protobuf:"bytes,6,opt,name=upstream_cluster,json=upstreamCluster" json:"upstream_cluster,omitempty"`
	// This field is the IP and port on which the request from the user was
	// received, stored in ipv4:port or [ipv6]:port format.
	DestinationHost string `protobuf:"bytes,7,opt,name=destination_host,json=destinationHost" json:"destination_host,omitempty"`
	// Size of the HTTP request body in bytes
	RequestBodyBytes *google_protobuf.UInt64Value `protobuf:"bytes,8,opt,name=request_body_bytes,json=requestBodyBytes" json:"request_body_bytes,omitempty"`
	// Size of the HTTP response body in bytes
	ResponseBodyBytes *google_protobuf.UInt64Value `protobuf:"bytes,9,opt,name=response_body_bytes,json=responseBodyBytes" json:"response_body_bytes,omitempty"`
	// Size of the HTTP request headers in bytes
	RequestHeadersBytes *google_protobuf.UInt64Value `protobuf:"bytes,10,opt,name=request_headers_bytes,json=requestHeadersBytes" json:"request_headers_bytes,omitempty"`
	// Size of the HTTP response headers in bytes
	ResponseHeadersBytes *google_protobuf.UInt64Value `protobuf:"bytes,11,opt,name=response_headers_bytes,json=responseHeadersBytes" json:"response_headers_bytes,omitempty"`
	// Whether the request arrived via a secure (TLS) protocol
	Secure *google_protobuf.BoolValue `protobuf:"bytes,12,opt,name=secure" json:"secure,omitempty"`
	// Whether the request is a HealthCheck request
	HealthCheck *google_protobuf.BoolValue `protobuf:"bytes,13,opt,name=health_check,json=healthCheck" json:"health_check,omitempty"`
	// The HTTP response code
	ResponseCode *google_protobuf.UInt32Value `protobuf:"bytes,14,opt,name=response_code,json=responseCode" json:"response_code,omitempty"`
	// User agent as sent by client HTTP
	UserAgent string `protobuf:"bytes,15,opt,name=user_agent,json=userAgent" json:"user_agent,omitempty"`
	// Path
	//
	// This is the Path portion from the incoming request URI
	Path string `protobuf:"bytes,17,opt,name=path" json:"path,omitempty"`
	// Referer header as sent by client HTTP
	// (Referer is spelled to match the HTTP spec, not English).
	Referer string `protobuf:"bytes,18,opt,name=referer" json:"referer,omitempty"`
	// X-Forwarded-For request header
	ForwardedFor string `protobuf:"bytes,19,opt,name=forwarded_for,json=forwardedFor" json:"forwarded_for,omitempty"`
	// X-Request-Id request header
	//
	// This header is used by Envoy to uniquely identify a request.
	// It will be generated for all external requests and internal requests that
	// do not already have a request ID.  So this field can be guaranteed to exist
	// and be unique for request tracing purposes.
	RequestId string `protobuf:"bytes,20,opt,name=request_id,json=requestId" json:"request_id,omitempty"`
	// HTTP2 :authority header value or HTTP1.1 Host header value
	Authority string `protobuf:"bytes,21,opt,name=authority" json:"authority,omitempty"`
	// Duration (milliseconds)
	//
	// The total duration it took to service this request from the StartTime until
	// the response was written to the user.
	ResponseDuration *google_protobuf1.Duration `protobuf:"bytes,22,opt,name=response_duration,json=responseDuration" json:"response_duration,omitempty"`
	// Upstream Service Time Duration
	//
	// From the X-Envoy-Upstream-Service-Time response header. This is the amount it took
	// the upstream server to service the request.
	UpstreamServiceDuration *google_protobuf1.Duration `protobuf:"bytes,23,opt,name=upstream_service_duration,json=upstreamServiceDuration" json:"upstream_service_duration,omitempty"`
	// Original Path from the X-Envoy-Original-Path header.
	OriginalPath string `protobuf:"bytes,24,opt,name=original_path,json=originalPath" json:"original_path,omitempty"`
	// All metadata encountered during request processing, including endpoint
	// selection.
	//
	// This can be used to associate IDs attached to the various configurations
	// used to process this request with the access log entry.  For example, a
	// route created from a higher level forwarding rule with some ID can place
	// that ID in this field and cross reference later. It can also be used to
	// determine if a canary endpoint was used or not.
	Metadata *google_protobuf2.Struct `protobuf:"bytes,25,opt,name=metadata" json:"metadata,omitempty"`
	// Headers configured for logging but not covered by a specific field.
	RequestHeaders  []*envoy_api_v21.HeaderValue `protobuf:"bytes,26,rep,name=request_headers,json=requestHeaders" json:"request_headers,omitempty"`
	ResponseHeaders []*envoy_api_v21.HeaderValue `protobuf:"bytes,27,rep,name=response_headers,json=responseHeaders" json:"response_headers,omitempty"`
	// SNI hostname from handshake.
	TlsSniHostname string                    `protobuf:"bytes,28,opt,name=tls_sni_hostname,json=tlsSniHostname" json:"tls_sni_hostname,omitempty"`
	TlsVersion     AccessLogEntry_TLSVersion `protobuf:"varint,29,opt,name=tls_version,json=tlsVersion,enum=envoy.api.v2.filter.AccessLogEntry_TLSVersion" json:"tls_version,omitempty"`
	// TLS Cipher suite negotiated during TLS handshake.
	// The value is four hex digits defined by the IANA TLS Cipher Suite Registry,
	// eg, "009C" for TLS_RSA_WITH_AES_128_GCM_SHA256.
	//
	// Here is is expressed as an integer.
	TlsCipherSuite *google_protobuf.UInt32Value `protobuf:"bytes,30,opt,name=tls_cipher_suite,json=tlsCipherSuite" json:"tls_cipher_suite,omitempty"`
}

func (m *AccessLogEntry) Reset()                    { *m = AccessLogEntry{} }
func (m *AccessLogEntry) String() string            { return proto.CompactTextString(m) }
func (*AccessLogEntry) ProtoMessage()               {}
func (*AccessLogEntry) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *AccessLogEntry) GetStartTime() *google_protobuf3.Timestamp {
	if m != nil {
		return m.StartTime
	}
	return nil
}

func (m *AccessLogEntry) GetRequestBodyBytes() *google_protobuf.UInt64Value {
	if m != nil {
		return m.RequestBodyBytes
	}
	return nil
}

func (m *AccessLogEntry) GetResponseBodyBytes() *google_protobuf.UInt64Value {
	if m != nil {
		return m.ResponseBodyBytes
	}
	return nil
}

func (m *AccessLogEntry) GetRequestHeadersBytes() *google_protobuf.UInt64Value {
	if m != nil {
		return m.RequestHeadersBytes
	}
	return nil
}

func (m *AccessLogEntry) GetResponseHeadersBytes() *google_protobuf.UInt64Value {
	if m != nil {
		return m.ResponseHeadersBytes
	}
	return nil
}

func (m *AccessLogEntry) GetSecure() *google_protobuf.BoolValue {
	if m != nil {
		return m.Secure
	}
	return nil
}

func (m *AccessLogEntry) GetHealthCheck() *google_protobuf.BoolValue {
	if m != nil {
		return m.HealthCheck
	}
	return nil
}

func (m *AccessLogEntry) GetResponseCode() *google_protobuf.UInt32Value {
	if m != nil {
		return m.ResponseCode
	}
	return nil
}

func (m *AccessLogEntry) GetResponseDuration() *google_protobuf1.Duration {
	if m != nil {
		return m.ResponseDuration
	}
	return nil
}

func (m *AccessLogEntry) GetUpstreamServiceDuration() *google_protobuf1.Duration {
	if m != nil {
		return m.UpstreamServiceDuration
	}
	return nil
}

func (m *AccessLogEntry) GetMetadata() *google_protobuf2.Struct {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func (m *AccessLogEntry) GetRequestHeaders() []*envoy_api_v21.HeaderValue {
	if m != nil {
		return m.RequestHeaders
	}
	return nil
}

func (m *AccessLogEntry) GetResponseHeaders() []*envoy_api_v21.HeaderValue {
	if m != nil {
		return m.ResponseHeaders
	}
	return nil
}

func (m *AccessLogEntry) GetTlsCipherSuite() *google_protobuf.UInt32Value {
	if m != nil {
		return m.TlsCipherSuite
	}
	return nil
}

// Filter on some integer comparison.
type ComparisonFilter struct {
	Op ComparisonFilter_Op `protobuf:"varint,1,opt,name=op,enum=envoy.api.v2.filter.ComparisonFilter_Op" json:"op,omitempty"`
	// Value to compare against.
	Value *envoy_api_v21.RuntimeUInt32 `protobuf:"bytes,2,opt,name=value" json:"value,omitempty"`
}

func (m *ComparisonFilter) Reset()                    { *m = ComparisonFilter{} }
func (m *ComparisonFilter) String() string            { return proto.CompactTextString(m) }
func (*ComparisonFilter) ProtoMessage()               {}
func (*ComparisonFilter) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *ComparisonFilter) GetValue() *envoy_api_v21.RuntimeUInt32 {
	if m != nil {
		return m.Value
	}
	return nil
}

// Filters on HTTP response/status code.
type StatusCodeFilter struct {
	Comparison *ComparisonFilter `protobuf:"bytes,1,opt,name=comparison" json:"comparison,omitempty"`
}

func (m *StatusCodeFilter) Reset()                    { *m = StatusCodeFilter{} }
func (m *StatusCodeFilter) String() string            { return proto.CompactTextString(m) }
func (*StatusCodeFilter) ProtoMessage()               {}
func (*StatusCodeFilter) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *StatusCodeFilter) GetComparison() *ComparisonFilter {
	if m != nil {
		return m.Comparison
	}
	return nil
}

// Filters on total request duration in milliseconds.
type DurationFilter struct {
	Comparison *ComparisonFilter `protobuf:"bytes,1,opt,name=comparison" json:"comparison,omitempty"`
}

func (m *DurationFilter) Reset()                    { *m = DurationFilter{} }
func (m *DurationFilter) String() string            { return proto.CompactTextString(m) }
func (*DurationFilter) ProtoMessage()               {}
func (*DurationFilter) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *DurationFilter) GetComparison() *ComparisonFilter {
	if m != nil {
		return m.Comparison
	}
	return nil
}

// Filters for requests that are not health check requests. A health check
// request is marked by the health check filter.
type NotHealthCheckFilter struct {
}

func (m *NotHealthCheckFilter) Reset()                    { *m = NotHealthCheckFilter{} }
func (m *NotHealthCheckFilter) String() string            { return proto.CompactTextString(m) }
func (*NotHealthCheckFilter) ProtoMessage()               {}
func (*NotHealthCheckFilter) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

// Filters for requests that are traceable. See the tracing overview for more
// information on how a request becomes traceable.
type TraceableFilter struct {
}

func (m *TraceableFilter) Reset()                    { *m = TraceableFilter{} }
func (m *TraceableFilter) String() string            { return proto.CompactTextString(m) }
func (*TraceableFilter) ProtoMessage()               {}
func (*TraceableFilter) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

// Filters for random sampling of requests. Sampling pivots on the header
// x-request-id being present. If x-request-id is present, the filter will
// consistently sample across multiple hosts based on the runtime key value and
// the value extracted from x-request-id. If it is missing, the filter will
// randomly sample based on the runtime key value.
type RuntimeFilter struct {
	// Runtime key to get the percentage of requests to be sampled. This runtime
	// control is specified in the range 0-100 and defaults to 0.
	RuntimeKey string `protobuf:"bytes,1,opt,name=runtime_key,json=runtimeKey" json:"runtime_key,omitempty"`
}

func (m *RuntimeFilter) Reset()                    { *m = RuntimeFilter{} }
func (m *RuntimeFilter) String() string            { return proto.CompactTextString(m) }
func (*RuntimeFilter) ProtoMessage()               {}
func (*RuntimeFilter) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

// Performs a logical “and” operation on the result of each filter in filters.
// Filters are evaluated sequentially and if one of them returns false, the
// filter returns false immediately.
type AndFilter struct {
	Filters []*AccessLogFilter `protobuf:"bytes,1,rep,name=filters" json:"filters,omitempty"`
}

func (m *AndFilter) Reset()                    { *m = AndFilter{} }
func (m *AndFilter) String() string            { return proto.CompactTextString(m) }
func (*AndFilter) ProtoMessage()               {}
func (*AndFilter) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *AndFilter) GetFilters() []*AccessLogFilter {
	if m != nil {
		return m.Filters
	}
	return nil
}

// Performs a logical “or” operation on the result of each individual filter.
// Filters are evaluated sequentially and if one of them returns true, the
// filter returns true immediately.
type OrFilter struct {
	Filters []*AccessLogFilter `protobuf:"bytes,2,rep,name=filters" json:"filters,omitempty"`
}

func (m *OrFilter) Reset()                    { *m = OrFilter{} }
func (m *OrFilter) String() string            { return proto.CompactTextString(m) }
func (*OrFilter) ProtoMessage()               {}
func (*OrFilter) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *OrFilter) GetFilters() []*AccessLogFilter {
	if m != nil {
		return m.Filters
	}
	return nil
}

type AccessLogFilter struct {
	// Types that are valid to be assigned to FilterSpecifier:
	//	*AccessLogFilter_StatusCodeFilter
	//	*AccessLogFilter_DurationFilter
	//	*AccessLogFilter_NotHealthCheckFilter
	//	*AccessLogFilter_TraceableFilter
	//	*AccessLogFilter_RuntimeFilter
	//	*AccessLogFilter_AndFilter
	//	*AccessLogFilter_OrFilter
	FilterSpecifier isAccessLogFilter_FilterSpecifier `protobuf_oneof:"filter_specifier"`
}

func (m *AccessLogFilter) Reset()                    { *m = AccessLogFilter{} }
func (m *AccessLogFilter) String() string            { return proto.CompactTextString(m) }
func (*AccessLogFilter) ProtoMessage()               {}
func (*AccessLogFilter) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

type isAccessLogFilter_FilterSpecifier interface {
	isAccessLogFilter_FilterSpecifier()
}

type AccessLogFilter_StatusCodeFilter struct {
	StatusCodeFilter *StatusCodeFilter `protobuf:"bytes,1,opt,name=status_code_filter,json=statusCodeFilter,oneof"`
}
type AccessLogFilter_DurationFilter struct {
	DurationFilter *DurationFilter `protobuf:"bytes,2,opt,name=duration_filter,json=durationFilter,oneof"`
}
type AccessLogFilter_NotHealthCheckFilter struct {
	NotHealthCheckFilter *NotHealthCheckFilter `protobuf:"bytes,3,opt,name=not_health_check_filter,json=notHealthCheckFilter,oneof"`
}
type AccessLogFilter_TraceableFilter struct {
	TraceableFilter *TraceableFilter `protobuf:"bytes,4,opt,name=traceable_filter,json=traceableFilter,oneof"`
}
type AccessLogFilter_RuntimeFilter struct {
	RuntimeFilter *RuntimeFilter `protobuf:"bytes,5,opt,name=runtime_filter,json=runtimeFilter,oneof"`
}
type AccessLogFilter_AndFilter struct {
	AndFilter *AndFilter `protobuf:"bytes,6,opt,name=and_filter,json=andFilter,oneof"`
}
type AccessLogFilter_OrFilter struct {
	OrFilter *OrFilter `protobuf:"bytes,7,opt,name=or_filter,json=orFilter,oneof"`
}

func (*AccessLogFilter_StatusCodeFilter) isAccessLogFilter_FilterSpecifier()     {}
func (*AccessLogFilter_DurationFilter) isAccessLogFilter_FilterSpecifier()       {}
func (*AccessLogFilter_NotHealthCheckFilter) isAccessLogFilter_FilterSpecifier() {}
func (*AccessLogFilter_TraceableFilter) isAccessLogFilter_FilterSpecifier()      {}
func (*AccessLogFilter_RuntimeFilter) isAccessLogFilter_FilterSpecifier()        {}
func (*AccessLogFilter_AndFilter) isAccessLogFilter_FilterSpecifier()            {}
func (*AccessLogFilter_OrFilter) isAccessLogFilter_FilterSpecifier()             {}

func (m *AccessLogFilter) GetFilterSpecifier() isAccessLogFilter_FilterSpecifier {
	if m != nil {
		return m.FilterSpecifier
	}
	return nil
}

func (m *AccessLogFilter) GetStatusCodeFilter() *StatusCodeFilter {
	if x, ok := m.GetFilterSpecifier().(*AccessLogFilter_StatusCodeFilter); ok {
		return x.StatusCodeFilter
	}
	return nil
}

func (m *AccessLogFilter) GetDurationFilter() *DurationFilter {
	if x, ok := m.GetFilterSpecifier().(*AccessLogFilter_DurationFilter); ok {
		return x.DurationFilter
	}
	return nil
}

func (m *AccessLogFilter) GetNotHealthCheckFilter() *NotHealthCheckFilter {
	if x, ok := m.GetFilterSpecifier().(*AccessLogFilter_NotHealthCheckFilter); ok {
		return x.NotHealthCheckFilter
	}
	return nil
}

func (m *AccessLogFilter) GetTraceableFilter() *TraceableFilter {
	if x, ok := m.GetFilterSpecifier().(*AccessLogFilter_TraceableFilter); ok {
		return x.TraceableFilter
	}
	return nil
}

func (m *AccessLogFilter) GetRuntimeFilter() *RuntimeFilter {
	if x, ok := m.GetFilterSpecifier().(*AccessLogFilter_RuntimeFilter); ok {
		return x.RuntimeFilter
	}
	return nil
}

func (m *AccessLogFilter) GetAndFilter() *AndFilter {
	if x, ok := m.GetFilterSpecifier().(*AccessLogFilter_AndFilter); ok {
		return x.AndFilter
	}
	return nil
}

func (m *AccessLogFilter) GetOrFilter() *OrFilter {
	if x, ok := m.GetFilterSpecifier().(*AccessLogFilter_OrFilter); ok {
		return x.OrFilter
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*AccessLogFilter) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _AccessLogFilter_OneofMarshaler, _AccessLogFilter_OneofUnmarshaler, _AccessLogFilter_OneofSizer, []interface{}{
		(*AccessLogFilter_StatusCodeFilter)(nil),
		(*AccessLogFilter_DurationFilter)(nil),
		(*AccessLogFilter_NotHealthCheckFilter)(nil),
		(*AccessLogFilter_TraceableFilter)(nil),
		(*AccessLogFilter_RuntimeFilter)(nil),
		(*AccessLogFilter_AndFilter)(nil),
		(*AccessLogFilter_OrFilter)(nil),
	}
}

func _AccessLogFilter_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*AccessLogFilter)
	// filter_specifier
	switch x := m.FilterSpecifier.(type) {
	case *AccessLogFilter_StatusCodeFilter:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.StatusCodeFilter); err != nil {
			return err
		}
	case *AccessLogFilter_DurationFilter:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.DurationFilter); err != nil {
			return err
		}
	case *AccessLogFilter_NotHealthCheckFilter:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.NotHealthCheckFilter); err != nil {
			return err
		}
	case *AccessLogFilter_TraceableFilter:
		b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.TraceableFilter); err != nil {
			return err
		}
	case *AccessLogFilter_RuntimeFilter:
		b.EncodeVarint(5<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.RuntimeFilter); err != nil {
			return err
		}
	case *AccessLogFilter_AndFilter:
		b.EncodeVarint(6<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.AndFilter); err != nil {
			return err
		}
	case *AccessLogFilter_OrFilter:
		b.EncodeVarint(7<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.OrFilter); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("AccessLogFilter.FilterSpecifier has unexpected type %T", x)
	}
	return nil
}

func _AccessLogFilter_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*AccessLogFilter)
	switch tag {
	case 1: // filter_specifier.status_code_filter
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(StatusCodeFilter)
		err := b.DecodeMessage(msg)
		m.FilterSpecifier = &AccessLogFilter_StatusCodeFilter{msg}
		return true, err
	case 2: // filter_specifier.duration_filter
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(DurationFilter)
		err := b.DecodeMessage(msg)
		m.FilterSpecifier = &AccessLogFilter_DurationFilter{msg}
		return true, err
	case 3: // filter_specifier.not_health_check_filter
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(NotHealthCheckFilter)
		err := b.DecodeMessage(msg)
		m.FilterSpecifier = &AccessLogFilter_NotHealthCheckFilter{msg}
		return true, err
	case 4: // filter_specifier.traceable_filter
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(TraceableFilter)
		err := b.DecodeMessage(msg)
		m.FilterSpecifier = &AccessLogFilter_TraceableFilter{msg}
		return true, err
	case 5: // filter_specifier.runtime_filter
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(RuntimeFilter)
		err := b.DecodeMessage(msg)
		m.FilterSpecifier = &AccessLogFilter_RuntimeFilter{msg}
		return true, err
	case 6: // filter_specifier.and_filter
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(AndFilter)
		err := b.DecodeMessage(msg)
		m.FilterSpecifier = &AccessLogFilter_AndFilter{msg}
		return true, err
	case 7: // filter_specifier.or_filter
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(OrFilter)
		err := b.DecodeMessage(msg)
		m.FilterSpecifier = &AccessLogFilter_OrFilter{msg}
		return true, err
	default:
		return false, nil
	}
}

func _AccessLogFilter_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*AccessLogFilter)
	// filter_specifier
	switch x := m.FilterSpecifier.(type) {
	case *AccessLogFilter_StatusCodeFilter:
		s := proto.Size(x.StatusCodeFilter)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *AccessLogFilter_DurationFilter:
		s := proto.Size(x.DurationFilter)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *AccessLogFilter_NotHealthCheckFilter:
		s := proto.Size(x.NotHealthCheckFilter)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *AccessLogFilter_TraceableFilter:
		s := proto.Size(x.TraceableFilter)
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *AccessLogFilter_RuntimeFilter:
		s := proto.Size(x.RuntimeFilter)
		n += proto.SizeVarint(5<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *AccessLogFilter_AndFilter:
		s := proto.Size(x.AndFilter)
		n += proto.SizeVarint(6<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *AccessLogFilter_OrFilter:
		s := proto.Size(x.OrFilter)
		n += proto.SizeVarint(7<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Custom configuration for an AccessLog that writes log entries directly to a file.
// Configures the built-in "envoy.file_access_log" AccessLog.
type FileAccessLog struct {
	// A path to a local file to which to write the access log entries.
	Path string `protobuf:"bytes,1,opt,name=path" json:"path,omitempty"`
	// [V2-API-DIFF] In addition to the existing format specifiers, the following
	// additional specifiers will be available:
	// %TLS_SNI_HOSTNAME%: SNI from handshake.
	// %TLS_VERSION%: Possible values include: “TLSv1”, “TLSv1.1”,
	//     “TLSv1.2”, “TLSv1.3”.
	// %TLS_CIPHER_SUITE%: Cipher suite negotiated during the TLS handshake. The
	//     value is four hex digits defined by the IANA TLS Cipher Suite Registry,
	//     e.g. “009C” for TLS_RSA_WITH_AES_128_GCM_SHA256.
	// TODO(htuch): Document how envoy.http_connection_manager.access_log values
	// can be accessed in the format specifier.
	Format string `protobuf:"bytes,2,opt,name=format" json:"format,omitempty"`
}

func (m *FileAccessLog) Reset()                    { *m = FileAccessLog{} }
func (m *FileAccessLog) String() string            { return proto.CompactTextString(m) }
func (*FileAccessLog) ProtoMessage()               {}
func (*FileAccessLog) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

// Configuration for the built-in "envoy.grpc_access_log" access log type.
type AccessLogServiceConfig struct {
	// The friendly name of the access log to be returned in StreamAccessLogsMessage.Identifier. This
	// allows the access log server to differentiate between different access logs coming from the
	// same Envoy.
	LogName string `protobuf:"bytes,1,opt,name=log_name,json=logName" json:"log_name,omitempty"`
	// The name of the upstream cluster that hosts the access log service. The cluster must be
	// configured in the cluster manager.
	ClusterName string `protobuf:"bytes,2,opt,name=cluster_name,json=clusterName" json:"cluster_name,omitempty"`
}

func (m *AccessLogServiceConfig) Reset()                    { *m = AccessLogServiceConfig{} }
func (m *AccessLogServiceConfig) String() string            { return proto.CompactTextString(m) }
func (*AccessLogServiceConfig) ProtoMessage()               {}
func (*AccessLogServiceConfig) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

// Stream message for the StreamAccessLogs API. Envoy will open a stream to the server and stream
// access logs without ever expecting a response.
type StreamAccessLogsMessage struct {
	// Identifier data that will only be sent in the first message on the stream. This is effectively
	// structured metadata and is a performance optimization.
	Identifier *StreamAccessLogsMessage_Identifier `protobuf:"bytes,1,opt,name=identifier" json:"identifier,omitempty"`
	// A list of access logs.
	Logs []*AccessLogEntry `protobuf:"bytes,2,rep,name=logs" json:"logs,omitempty"`
}

func (m *StreamAccessLogsMessage) Reset()                    { *m = StreamAccessLogsMessage{} }
func (m *StreamAccessLogsMessage) String() string            { return proto.CompactTextString(m) }
func (*StreamAccessLogsMessage) ProtoMessage()               {}
func (*StreamAccessLogsMessage) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

func (m *StreamAccessLogsMessage) GetIdentifier() *StreamAccessLogsMessage_Identifier {
	if m != nil {
		return m.Identifier
	}
	return nil
}

func (m *StreamAccessLogsMessage) GetLogs() []*AccessLogEntry {
	if m != nil {
		return m.Logs
	}
	return nil
}

type StreamAccessLogsMessage_Identifier struct {
	// The node sending the access log messages over the stream.
	Node *envoy_api_v21.Node `protobuf:"bytes,1,opt,name=node" json:"node,omitempty"`
	// The friendly name of the log configured in AccessLogServiceConfig.
	LogName string `protobuf:"bytes,2,opt,name=log_name,json=logName" json:"log_name,omitempty"`
}

func (m *StreamAccessLogsMessage_Identifier) Reset()         { *m = StreamAccessLogsMessage_Identifier{} }
func (m *StreamAccessLogsMessage_Identifier) String() string { return proto.CompactTextString(m) }
func (*StreamAccessLogsMessage_Identifier) ProtoMessage()    {}
func (*StreamAccessLogsMessage_Identifier) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{12, 0}
}

func (m *StreamAccessLogsMessage_Identifier) GetNode() *envoy_api_v21.Node {
	if m != nil {
		return m.Node
	}
	return nil
}

// Empty response for the StreamAccessLogs API. Will never be sent. See below.
type StreamAccessLogsResponse struct {
}

func (m *StreamAccessLogsResponse) Reset()                    { *m = StreamAccessLogsResponse{} }
func (m *StreamAccessLogsResponse) String() string            { return proto.CompactTextString(m) }
func (*StreamAccessLogsResponse) ProtoMessage()               {}
func (*StreamAccessLogsResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{13} }

type AccessLog struct {
	// The name of the access log implementation to instantiate. The name must
	// match a statically registered access log. Current built-in loggers include:
	// 1) "envoy.file_access_log"
	// 2) "envoy.grpc_access_log"
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// Filter which is used to determine if the access log needs to be written.
	Filter *AccessLogFilter `protobuf:"bytes,2,opt,name=filter" json:"filter,omitempty"`
	// Custom configuration that depends on the access log being instantiated. built-in configurations
	// include:
	// 1) "envoy.file_access_log": FileAccessLog
	// 2) "envoy.grpc_access_log": AccessLogServiceConfig
	Config *google_protobuf2.Struct `protobuf:"bytes,3,opt,name=config" json:"config,omitempty"`
}

func (m *AccessLog) Reset()                    { *m = AccessLog{} }
func (m *AccessLog) String() string            { return proto.CompactTextString(m) }
func (*AccessLog) ProtoMessage()               {}
func (*AccessLog) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{14} }

func (m *AccessLog) GetFilter() *AccessLogFilter {
	if m != nil {
		return m.Filter
	}
	return nil
}

func (m *AccessLog) GetConfig() *google_protobuf2.Struct {
	if m != nil {
		return m.Config
	}
	return nil
}

func init() {
	proto.RegisterType((*AccessLogEntry)(nil), "envoy.api.v2.filter.AccessLogEntry")
	proto.RegisterType((*ComparisonFilter)(nil), "envoy.api.v2.filter.ComparisonFilter")
	proto.RegisterType((*StatusCodeFilter)(nil), "envoy.api.v2.filter.StatusCodeFilter")
	proto.RegisterType((*DurationFilter)(nil), "envoy.api.v2.filter.DurationFilter")
	proto.RegisterType((*NotHealthCheckFilter)(nil), "envoy.api.v2.filter.NotHealthCheckFilter")
	proto.RegisterType((*TraceableFilter)(nil), "envoy.api.v2.filter.TraceableFilter")
	proto.RegisterType((*RuntimeFilter)(nil), "envoy.api.v2.filter.RuntimeFilter")
	proto.RegisterType((*AndFilter)(nil), "envoy.api.v2.filter.AndFilter")
	proto.RegisterType((*OrFilter)(nil), "envoy.api.v2.filter.OrFilter")
	proto.RegisterType((*AccessLogFilter)(nil), "envoy.api.v2.filter.AccessLogFilter")
	proto.RegisterType((*FileAccessLog)(nil), "envoy.api.v2.filter.FileAccessLog")
	proto.RegisterType((*AccessLogServiceConfig)(nil), "envoy.api.v2.filter.AccessLogServiceConfig")
	proto.RegisterType((*StreamAccessLogsMessage)(nil), "envoy.api.v2.filter.StreamAccessLogsMessage")
	proto.RegisterType((*StreamAccessLogsMessage_Identifier)(nil), "envoy.api.v2.filter.StreamAccessLogsMessage.Identifier")
	proto.RegisterType((*StreamAccessLogsResponse)(nil), "envoy.api.v2.filter.StreamAccessLogsResponse")
	proto.RegisterType((*AccessLog)(nil), "envoy.api.v2.filter.AccessLog")
	proto.RegisterEnum("envoy.api.v2.filter.AccessLogEntry_Protocol", AccessLogEntry_Protocol_name, AccessLogEntry_Protocol_value)
	proto.RegisterEnum("envoy.api.v2.filter.AccessLogEntry_ResponseFlag", AccessLogEntry_ResponseFlag_name, AccessLogEntry_ResponseFlag_value)
	proto.RegisterEnum("envoy.api.v2.filter.AccessLogEntry_TLSVersion", AccessLogEntry_TLSVersion_name, AccessLogEntry_TLSVersion_value)
	proto.RegisterEnum("envoy.api.v2.filter.ComparisonFilter_Op", ComparisonFilter_Op_name, ComparisonFilter_Op_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for AccessLogService service

type AccessLogServiceClient interface {
	// Envoy will connect and send StreamAccessLogsMessage messages forever. It does not expect any
	// response to be sent as nothing would be done in the case of failure. The server should
	// disconnect if it expects Envoy to reconnect. In the future we may decide to add a different
	// API for "critical" access logs in which Envoy will buffer access logs for some period of time
	// until it gets an ACK so it could then retry. This API is designed for high throughput with the
	// expectation that it might be lossy.
	StreamAccessLogs(ctx context.Context, opts ...grpc.CallOption) (AccessLogService_StreamAccessLogsClient, error)
}

type accessLogServiceClient struct {
	cc *grpc.ClientConn
}

func NewAccessLogServiceClient(cc *grpc.ClientConn) AccessLogServiceClient {
	return &accessLogServiceClient{cc}
}

func (c *accessLogServiceClient) StreamAccessLogs(ctx context.Context, opts ...grpc.CallOption) (AccessLogService_StreamAccessLogsClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_AccessLogService_serviceDesc.Streams[0], c.cc, "/envoy.api.v2.filter.AccessLogService/StreamAccessLogs", opts...)
	if err != nil {
		return nil, err
	}
	x := &accessLogServiceStreamAccessLogsClient{stream}
	return x, nil
}

type AccessLogService_StreamAccessLogsClient interface {
	Send(*StreamAccessLogsMessage) error
	CloseAndRecv() (*StreamAccessLogsResponse, error)
	grpc.ClientStream
}

type accessLogServiceStreamAccessLogsClient struct {
	grpc.ClientStream
}

func (x *accessLogServiceStreamAccessLogsClient) Send(m *StreamAccessLogsMessage) error {
	return x.ClientStream.SendMsg(m)
}

func (x *accessLogServiceStreamAccessLogsClient) CloseAndRecv() (*StreamAccessLogsResponse, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(StreamAccessLogsResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for AccessLogService service

type AccessLogServiceServer interface {
	// Envoy will connect and send StreamAccessLogsMessage messages forever. It does not expect any
	// response to be sent as nothing would be done in the case of failure. The server should
	// disconnect if it expects Envoy to reconnect. In the future we may decide to add a different
	// API for "critical" access logs in which Envoy will buffer access logs for some period of time
	// until it gets an ACK so it could then retry. This API is designed for high throughput with the
	// expectation that it might be lossy.
	StreamAccessLogs(AccessLogService_StreamAccessLogsServer) error
}

func RegisterAccessLogServiceServer(s *grpc.Server, srv AccessLogServiceServer) {
	s.RegisterService(&_AccessLogService_serviceDesc, srv)
}

func _AccessLogService_StreamAccessLogs_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(AccessLogServiceServer).StreamAccessLogs(&accessLogServiceStreamAccessLogsServer{stream})
}

type AccessLogService_StreamAccessLogsServer interface {
	SendAndClose(*StreamAccessLogsResponse) error
	Recv() (*StreamAccessLogsMessage, error)
	grpc.ServerStream
}

type accessLogServiceStreamAccessLogsServer struct {
	grpc.ServerStream
}

func (x *accessLogServiceStreamAccessLogsServer) SendAndClose(m *StreamAccessLogsResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *accessLogServiceStreamAccessLogsServer) Recv() (*StreamAccessLogsMessage, error) {
	m := new(StreamAccessLogsMessage)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _AccessLogService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "envoy.api.v2.filter.AccessLogService",
	HandlerType: (*AccessLogServiceServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "StreamAccessLogs",
			Handler:       _AccessLogService_StreamAccessLogs_Handler,
			ClientStreams: true,
		},
	},
	Metadata: "api/filter/accesslog.proto",
}

func init() { proto.RegisterFile("api/filter/accesslog.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 1683 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x57, 0x51, 0x53, 0xdb, 0xca,
	0x15, 0xb6, 0x0d, 0x18, 0x7c, 0x0c, 0xb6, 0x58, 0x08, 0x08, 0x42, 0x12, 0x2a, 0xda, 0x0e, 0x77,
	0xe6, 0xd6, 0x24, 0x4e, 0xa7, 0xb7, 0x9d, 0xde, 0xb6, 0x63, 0x8c, 0x7c, 0xed, 0xc4, 0x58, 0x44,
	0x96, 0x61, 0xf2, 0xa4, 0x11, 0xd6, 0x62, 0x6b, 0xae, 0xd0, 0xba, 0xbb, 0x6b, 0xee, 0xf0, 0x07,
	0xda, 0xb7, 0xbe, 0xf5, 0xcf, 0xf4, 0x4f, 0xf4, 0x0f, 0xf5, 0xa1, 0xb3, 0xbb, 0x92, 0xb0, 0x1c,
	0x27, 0x71, 0x3b, 0xf7, 0xc9, 0xbb, 0x67, 0xcf, 0xf7, 0xed, 0xd9, 0x73, 0x3e, 0x9d, 0x5d, 0xc3,
	0xa1, 0x37, 0x09, 0xce, 0xee, 0x82, 0x90, 0x63, 0x7a, 0xe6, 0x0d, 0x87, 0x98, 0xb1, 0x90, 0x8c,
	0x6a, 0x13, 0x4a, 0x38, 0x41, 0x3b, 0x38, 0x7a, 0x20, 0x8f, 0x35, 0x6f, 0x12, 0xd4, 0x1e, 0xea,
	0x35, 0xe5, 0x74, 0x58, 0x11, 0x80, 0x5b, 0x8f, 0x61, 0xe5, 0x74, 0xf8, 0x72, 0x44, 0xc8, 0x28,
	0xc4, 0x67, 0x72, 0x76, 0x3b, 0xbd, 0x3b, 0xf3, 0xa7, 0xd4, 0xe3, 0x01, 0x89, 0xe2, 0xf5, 0xa3,
	0xf9, 0x75, 0xc6, 0xe9, 0x74, 0xc8, 0xe3, 0xd5, 0x57, 0xf3, 0xab, 0x3c, 0xb8, 0xc7, 0x8c, 0x7b,
	0xf7, 0x93, 0xcf, 0xd1, 0xff, 0x44, 0xbd, 0xc9, 0x04, 0x53, 0xa6, 0xd6, 0x8d, 0xbf, 0x6d, 0x43,
	0xa5, 0x21, 0xe3, 0xee, 0x92, 0x91, 0x19, 0x71, 0xfa, 0x88, 0xce, 0xa1, 0x42, 0xf1, 0x5f, 0xa7,
	0x98, 0x71, 0xf7, 0x1e, 0xf3, 0x31, 0xf1, 0xf5, 0xfc, 0x71, 0xfe, 0xb4, 0x52, 0x7f, 0x5e, 0xcb,
	0x9c, 0xc7, 0x56, 0x3e, 0x97, 0xd2, 0xc5, 0xde, 0xa2, 0xb3, 0x53, 0xf4, 0x07, 0x00, 0xc6, 0x3d,
	0xca, 0x5d, 0x11, 0x8f, 0x5e, 0x38, 0xce, 0x9f, 0x96, 0xeb, 0x87, 0x35, 0x15, 0x4b, 0x2d, 0x89,
	0xa5, 0xe6, 0x24, 0xc1, 0xda, 0x25, 0xe9, 0x2d, 0xe6, 0xe8, 0x06, 0x34, 0xe9, 0x30, 0x24, 0xa1,
	0xfb, 0xe0, 0xd1, 0xc0, 0x8b, 0xb8, 0xbe, 0x22, 0x03, 0xf8, 0xb6, 0xb6, 0x20, 0xa1, 0xb5, 0x6c,
	0xf4, 0xb5, 0xab, 0x18, 0x6b, 0x57, 0x13, 0x96, 0x6b, 0x45, 0x82, 0x6e, 0xc4, 0xb9, 0xd8, 0x84,
	0x44, 0x0c, 0xbb, 0x77, 0xa1, 0x37, 0x62, 0xfa, 0xea, 0xf1, 0xca, 0x69, 0xa5, 0xfe, 0x7a, 0x19,
	0x5a, 0x3b, 0x46, 0xb6, 0x42, 0x6f, 0x24, 0x0e, 0xfb, 0x34, 0x63, 0xe8, 0x04, 0xb6, 0xa6, 0x13,
	0xc6, 0x29, 0xf6, 0xee, 0xdd, 0x31, 0x61, 0x5c, 0x5f, 0x3b, 0xce, 0x9f, 0x96, 0xec, 0xcd, 0xc4,
	0xd8, 0x26, 0x8c, 0xa3, 0x6f, 0x40, 0x4b, 0x9d, 0x86, 0xe1, 0x94, 0x71, 0x4c, 0xf5, 0xa2, 0xf4,
	0xab, 0x26, 0xf6, 0xa6, 0x32, 0x0b, 0x57, 0x1f, 0x33, 0x1e, 0x44, 0x52, 0x07, 0x8a, 0x72, 0x5d,
	0xb9, 0xce, 0xd8, 0x25, 0xeb, 0x3b, 0x40, 0x49, 0xad, 0x6e, 0x89, 0xff, 0xe8, 0xde, 0x3e, 0x72,
	0xcc, 0xf4, 0x0d, 0x99, 0xef, 0xa3, 0x4f, 0xf2, 0x3d, 0xe8, 0x44, 0xfc, 0x77, 0xbf, 0xbd, 0xf6,
	0xc2, 0x29, 0xb6, 0xb5, 0x18, 0x77, 0x4e, 0xfc, 0xc7, 0x73, 0x81, 0x42, 0x5d, 0xd8, 0x49, 0xf3,
	0x33, 0x43, 0x56, 0x5a, 0x82, 0x6c, 0x3b, 0x01, 0x3e, 0xb1, 0x5d, 0xc1, 0xb3, 0x24, 0xb2, 0x31,
	0xf6, 0x7c, 0x4c, 0x59, 0xcc, 0x07, 0x4b, 0xf0, 0xed, 0xc4, 0xd0, 0xb6, 0x42, 0x2a, 0x46, 0x1b,
	0xf6, 0xd2, 0xf8, 0xb2, 0x94, 0xe5, 0x25, 0x28, 0x77, 0x13, 0x6c, 0x86, 0xb3, 0x0e, 0x45, 0x86,
	0x87, 0x53, 0x8a, 0xf5, 0xcd, 0xcf, 0x68, 0xf4, 0x9c, 0x08, 0x05, 0x09, 0x86, 0xd8, 0x13, 0xfd,
	0x09, 0x36, 0xc7, 0xd8, 0x0b, 0xf9, 0xd8, 0x1d, 0x8e, 0xf1, 0xf0, 0x47, 0x7d, 0xeb, 0xab, 0xc8,
	0xb2, 0xf2, 0x6f, 0x0a, 0x77, 0xd4, 0x80, 0x54, 0x3e, 0xee, 0x90, 0xf8, 0x58, 0xaf, 0x7c, 0x21,
	0xfa, 0xb7, 0x75, 0xc5, 0xb0, 0x99, 0x40, 0x9a, 0xc4, 0xc7, 0xe8, 0x05, 0xc0, 0x94, 0x61, 0xea,
	0x7a, 0x23, 0x1c, 0x71, 0xbd, 0x2a, 0xa5, 0x51, 0x12, 0x96, 0x86, 0x30, 0x20, 0x04, 0xab, 0x13,
	0x8f, 0x8f, 0xf5, 0x6d, 0xb9, 0x20, 0xc7, 0x48, 0x87, 0x75, 0x8a, 0xef, 0x30, 0xc5, 0x54, 0x47,
	0xd2, 0x9c, 0x4c, 0x85, 0x7a, 0xef, 0x08, 0xfd, 0xc9, 0xa3, 0x3e, 0xf6, 0xdd, 0x3b, 0x42, 0xf5,
	0x1d, 0xa5, 0xde, 0xd4, 0xd8, 0x22, 0x54, 0xec, 0x98, 0x54, 0x33, 0xf0, 0xf5, 0x5d, 0xb5, 0x63,
	0x6c, 0xe9, 0xf8, 0xe8, 0x08, 0x4a, 0xde, 0x94, 0x8f, 0x09, 0x0d, 0xf8, 0xa3, 0xfe, 0x4c, 0xad,
	0xa6, 0x06, 0xd4, 0x82, 0x54, 0x1f, 0x6e, 0xd2, 0xdd, 0xf4, 0x3d, 0x79, 0xea, 0x83, 0x4f, 0x4e,
	0x7d, 0x11, 0x3b, 0x08, 0x81, 0x2a, 0x4c, 0x62, 0x41, 0x03, 0x38, 0x48, 0x3f, 0x21, 0x86, 0xe9,
	0x43, 0x30, 0x9c, 0xe1, 0xdb, 0xff, 0x1a, 0xdf, 0x7e, 0x82, 0xed, 0x2b, 0x68, 0x4a, 0x7b, 0x02,
	0x5b, 0x84, 0x06, 0xa3, 0x20, 0xf2, 0x42, 0x57, 0xe6, 0x4d, 0x57, 0x09, 0x48, 0x8c, 0x57, 0x22,
	0x7f, 0x6f, 0x61, 0xe3, 0x1e, 0x73, 0xcf, 0xf7, 0xb8, 0xa7, 0x1f, 0xc8, 0xad, 0xf6, 0x3f, 0xd9,
	0xaa, 0x2f, 0x3b, 0xb3, 0x9d, 0x3a, 0xa2, 0x73, 0xa8, 0xce, 0x7d, 0x03, 0xfa, 0xe1, 0xf1, 0x8a,
	0x0c, 0x33, 0xd3, 0x72, 0x94, 0x24, 0x55, 0xa5, 0x2b, 0x59, 0xe9, 0xa3, 0x0b, 0xd0, 0xe6, 0x55,
	0xaf, 0x3f, 0xff, 0x1a, 0x49, 0x75, 0x4e, 0xec, 0xe8, 0x14, 0x34, 0x1e, 0x32, 0x97, 0x45, 0x81,
	0x6c, 0x27, 0x91, 0x77, 0x8f, 0xf5, 0x23, 0x79, 0xcc, 0x0a, 0x0f, 0x59, 0x3f, 0x0a, 0xda, 0xb1,
	0x15, 0x59, 0x50, 0x16, 0x9e, 0x0f, 0x98, 0x32, 0x91, 0xd6, 0x17, 0xb2, 0xf3, 0xd6, 0x96, 0x69,
	0x91, 0x4e, 0xb7, 0x7f, 0xad, 0x50, 0x36, 0xf0, 0x90, 0xc5, 0x63, 0xd4, 0x52, 0x5b, 0x0f, 0x83,
	0xc9, 0x18, 0x53, 0x97, 0x4d, 0x03, 0x8e, 0xf5, 0x97, 0x4b, 0x48, 0x5e, 0x04, 0xd6, 0x94, 0xa0,
	0xbe, 0xc0, 0x18, 0x3f, 0xc0, 0x46, 0xd2, 0xdb, 0x91, 0x0e, 0xbb, 0x57, 0xb6, 0xe5, 0x58, 0x4d,
	0xab, 0xeb, 0x0e, 0x7a, 0xfd, 0x2b, 0xb3, 0xd9, 0x69, 0x75, 0xcc, 0x0b, 0x2d, 0x87, 0x00, 0x8a,
	0x6d, 0xc7, 0xb9, 0x7a, 0xf3, 0x5a, 0xcb, 0xa7, 0xe3, 0x37, 0x5a, 0x01, 0x95, 0x60, 0x4d, 0x8c,
	0xeb, 0xda, 0x8a, 0xf1, 0xaf, 0x02, 0x6c, 0xce, 0xb6, 0x73, 0x74, 0x04, 0x7a, 0xab, 0xd1, 0xe9,
	0x9a, 0x17, 0x6e, 0xd7, 0x6a, 0x36, 0xba, 0x6e, 0xdb, 0x6c, 0x74, 0x9d, 0x76, 0xb3, 0x6d, 0x36,
	0xdf, 0x6b, 0x39, 0xb4, 0x0f, 0x3b, 0x3d, 0x2b, 0xb6, 0x7d, 0x74, 0x07, 0x57, 0x7d, 0xc7, 0x36,
	0x1b, 0x97, 0x5a, 0x5e, 0xc0, 0x92, 0x99, 0x6b, 0x9b, 0x1f, 0x06, 0x66, 0xdf, 0x71, 0x9d, 0xce,
	0xa5, 0x69, 0x0d, 0x1c, 0xad, 0x80, 0xaa, 0x50, 0x56, 0x6c, 0xb6, 0xd9, 0x37, 0x1d, 0x6d, 0x05,
	0x1d, 0xc0, 0xb3, 0x19, 0xf7, 0x4b, 0xcb, 0x31, 0xe3, 0xa5, 0x55, 0xf4, 0x0a, 0x9e, 0xa7, 0x4b,
	0x4d, 0xab, 0xd7, 0x33, 0x9b, 0x4e, 0xc7, 0xea, 0xb9, 0x22, 0xa8, 0x81, 0x6d, 0x6a, 0x6b, 0xe8,
	0x04, 0x5e, 0x2d, 0x72, 0x70, 0x4c, 0xfb, 0xb2, 0xd3, 0x6b, 0x88, 0xb1, 0x56, 0x44, 0xcf, 0x60,
	0x3b, 0x75, 0xb2, 0xae, 0x4d, 0xbb, 0xd5, 0xb5, 0x6e, 0xb4, 0x75, 0x84, 0xa0, 0xd2, 0xb3, 0x5c,
	0xdb, 0x1a, 0x38, 0xa6, 0xdb, 0xb2, 0x06, 0xbd, 0x0b, 0x6d, 0x43, 0xd8, 0x2e, 0xcc, 0x6e, 0xe3,
	0xa3, 0xdb, 0xe9, 0xbd, 0x33, 0x9b, 0x8e, 0x79, 0xa1, 0x95, 0x84, 0xad, 0xd5, 0x18, 0x74, 0x9d,
	0x27, 0x1b, 0x20, 0x0d, 0x36, 0xed, 0x86, 0x63, 0xba, 0xdd, 0xce, 0x65, 0x47, 0x58, 0xca, 0xc6,
	0x0d, 0xc0, 0x53, 0x9d, 0x45, 0x6e, 0xae, 0x4d, 0xbb, 0x2f, 0x62, 0xc9, 0x96, 0xa1, 0x04, 0x6b,
	0x4e, 0xb7, 0xff, 0xf0, 0x46, 0xcb, 0xa3, 0x32, 0xac, 0xcb, 0xa1, 0x2b, 0xca, 0x90, 0x4e, 0xea,
	0xda, 0xca, 0xd3, 0xe4, 0xad, 0xb6, 0x6a, 0xfc, 0x33, 0x0f, 0x5a, 0x93, 0xdc, 0x4f, 0x3c, 0x1a,
	0x30, 0x12, 0xb5, 0xa4, 0xc2, 0xd0, 0xef, 0xa1, 0x40, 0x26, 0xf1, 0xf3, 0xe3, 0x74, 0xa1, 0x06,
	0xe7, 0x21, 0x35, 0x6b, 0x62, 0x17, 0xc8, 0x04, 0xbd, 0x81, 0xb5, 0x07, 0x21, 0xa3, 0xf8, 0xed,
	0x31, 0xff, 0x76, 0x99, 0x46, 0xe2, 0x61, 0xa2, 0xe4, 0x66, 0x2b, 0x4f, 0x63, 0x17, 0x0a, 0xd6,
	0x04, 0x15, 0xa1, 0x60, 0x7e, 0xd0, 0x72, 0xe2, 0xf7, 0x07, 0x53, 0xcb, 0x1b, 0x1f, 0x41, 0xeb,
	0x73, 0x8f, 0x4f, 0x99, 0xe8, 0xbc, 0x71, 0x58, 0x26, 0xc0, 0x30, 0xdd, 0x57, 0x86, 0x57, 0xae,
	0xff, 0x6a, 0xa9, 0xf0, 0xec, 0x19, 0xa0, 0x71, 0x03, 0x95, 0xa4, 0x09, 0xfd, 0xbc, 0xc4, 0x7b,
	0xb0, 0xdb, 0x23, 0xa2, 0x83, 0x24, 0x97, 0x8e, 0xf2, 0x31, 0xb6, 0xa1, 0xea, 0x50, 0x6f, 0x88,
	0xbd, 0xdb, 0x30, 0x3e, 0x8a, 0xf1, 0x1a, 0xb6, 0xe2, 0x64, 0xc4, 0x21, 0xbc, 0x82, 0x32, 0x55,
	0x06, 0xf7, 0x47, 0xfc, 0x28, 0x63, 0x28, 0xd9, 0x10, 0x9b, 0xde, 0xe3, 0x47, 0xe3, 0x3d, 0x94,
	0x1a, 0x91, 0x1f, 0x7b, 0xff, 0x19, 0xd6, 0x55, 0x40, 0x4c, 0xcf, 0xcb, 0xa6, 0xf4, 0xcb, 0x2f,
	0x77, 0x8a, 0x38, 0xd8, 0x04, 0x64, 0xbc, 0x83, 0x0d, 0x8b, 0x7e, 0xca, 0x55, 0xf8, 0x7f, 0xb8,
	0xfe, 0xbd, 0x0a, 0xd5, 0xb9, 0x45, 0x34, 0x00, 0xc4, 0x64, 0xf5, 0xe4, 0x55, 0xeb, 0x2a, 0xd7,
	0x2f, 0x26, 0x76, 0xbe, 0xd8, 0xed, 0x9c, 0xad, 0xb1, 0x79, 0x01, 0xf4, 0xa0, 0x9a, 0x5c, 0x3c,
	0x09, 0xa7, 0xd2, 0xd9, 0xc9, 0x42, 0xce, 0x6c, 0x95, 0xdb, 0x39, 0xbb, 0xe2, 0x67, 0xeb, 0x7e,
	0x0b, 0xfb, 0x11, 0x91, 0x97, 0x44, 0xfa, 0xac, 0x48, 0x78, 0x57, 0x24, 0xef, 0x37, 0x0b, 0x79,
	0x17, 0x15, 0xb9, 0x9d, 0xb3, 0x77, 0xa3, 0x05, 0x76, 0xf4, 0x01, 0x34, 0x9e, 0x14, 0x3f, 0x21,
	0x5f, 0x95, 0xe4, 0x8b, 0xf3, 0x3c, 0xa7, 0x94, 0x76, 0xce, 0xae, 0xf2, 0xac, 0x09, 0xbd, 0x87,
	0x4a, 0xa2, 0x95, 0x98, 0x70, 0x4d, 0x12, 0x1a, 0x0b, 0x09, 0x33, 0x3a, 0x6b, 0xe7, 0xec, 0x2d,
	0x9a, 0x11, 0xde, 0x5f, 0x00, 0xbc, 0xc8, 0x4f, 0x88, 0x8a, 0x92, 0xe8, 0xe5, 0x62, 0x05, 0x24,
	0xf2, 0x6b, 0xe7, 0xec, 0x92, 0x97, 0x6a, 0xf1, 0x7b, 0x28, 0x11, 0x9a, 0xe0, 0xd7, 0x25, 0xfe,
	0xc5, 0x42, 0x7c, 0xa2, 0xb8, 0x76, 0xce, 0xde, 0x20, 0xf1, 0xf8, 0x1c, 0x81, 0xa6, 0x96, 0x5d,
	0x36, 0xc1, 0xc3, 0xe0, 0x2e, 0xc0, 0xd4, 0xf8, 0x23, 0x6c, 0xb5, 0x82, 0x10, 0xa7, 0xa2, 0x4a,
	0x5f, 0x56, 0xf9, 0x99, 0x97, 0xd5, 0x1e, 0x14, 0xef, 0x08, 0xbd, 0xf7, 0xb8, 0x94, 0x40, 0xc9,
	0x8e, 0x67, 0xc6, 0x35, 0xec, 0xa5, 0xc0, 0xf8, 0xc9, 0xd1, 0x24, 0xd1, 0x5d, 0x30, 0x42, 0x07,
	0xb0, 0x11, 0x92, 0x91, 0x2b, 0x2f, 0x61, 0xc5, 0xb4, 0x1e, 0x92, 0x51, 0x4f, 0xdc, 0xbe, 0xbf,
	0x80, 0xcd, 0xf8, 0xcf, 0x81, 0x5a, 0x56, 0x94, 0xe5, 0xd8, 0x26, 0x5c, 0x8c, 0xff, 0xe4, 0x61,
	0xbf, 0x2f, 0x1f, 0x32, 0x29, 0x3d, 0xbb, 0xc4, 0x8c, 0x79, 0x23, 0xf1, 0xdf, 0x09, 0x02, 0x1f,
	0x47, 0x5c, 0x86, 0x1f, 0xcb, 0xfc, 0xbb, 0xcf, 0xc8, 0x7c, 0x21, 0x43, 0xad, 0x93, 0xc2, 0xed,
	0x19, 0x2a, 0xf4, 0x1d, 0xac, 0x86, 0x64, 0x94, 0x7c, 0x98, 0x27, 0x4b, 0x3c, 0x07, 0x6c, 0x09,
	0x38, 0xb4, 0x00, 0x9e, 0x28, 0xd1, 0xaf, 0x61, 0x35, 0x12, 0x4f, 0x5e, 0x15, 0x19, 0xca, 0xd2,
	0xf4, 0x88, 0x8f, 0x6d, 0xb9, 0x9e, 0xc9, 0x50, 0x21, 0x93, 0x21, 0xe3, 0x10, 0xf4, 0xf9, 0xd8,
	0x93, 0xcb, 0xdc, 0xf8, 0x47, 0x1e, 0x4a, 0x99, 0x62, 0xcd, 0xa4, 0x58, 0x8e, 0xd1, 0xf7, 0x50,
	0xcc, 0x7c, 0xaf, 0xcb, 0xb5, 0x98, 0x18, 0x83, 0xce, 0xa0, 0x38, 0x94, 0x25, 0x8c, 0xbf, 0xca,
	0xcf, 0x3e, 0x01, 0x63, 0xb7, 0xfa, 0xdf, 0xf3, 0xa0, 0xcd, 0x8b, 0x00, 0x31, 0x71, 0xa3, 0x64,
	0x4f, 0x80, 0xbe, 0xfd, 0x5f, 0x8a, 0x74, 0xf8, 0x9b, 0xa5, 0xbc, 0xd3, 0xb4, 0xe4, 0x4e, 0xf3,
	0xb7, 0x45, 0x19, 0xe2, 0xdb, 0xff, 0x06, 0x00, 0x00, 0xff, 0xff, 0x29, 0x9f, 0x6a, 0xf8, 0xb0,
	0x10, 0x00, 0x00,
}
