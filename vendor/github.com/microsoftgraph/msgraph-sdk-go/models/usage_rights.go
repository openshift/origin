// Code generated by Microsoft Kiota - DO NOT EDIT.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package models
import (
    "math"
    "strings"
)
type UsageRights int

const (
    UNKNOWN_USAGERIGHTS = 1
    DOCEDIT_USAGERIGHTS = 2
    EDIT_USAGERIGHTS = 4
    COMMENT_USAGERIGHTS = 8
    EXPORT_USAGERIGHTS = 16
    FORWARD_USAGERIGHTS = 32
    OWNER_USAGERIGHTS = 64
    PRINT_USAGERIGHTS = 128
    REPLY_USAGERIGHTS = 256
    REPLYALL_USAGERIGHTS = 512
    VIEW_USAGERIGHTS = 1024
    EXTRACT_USAGERIGHTS = 2048
    VIEWRIGHTSDATA_USAGERIGHTS = 4096
    EDITRIGHTSDATA_USAGERIGHTS = 8192
    OBJMODEL_USAGERIGHTS = 16384
    ACCESSDENIED_USAGERIGHTS = 32768
    USERDEFINEDPROTECTIONTYPENOTSUPPORTEDEXCEPTION_USAGERIGHTS = 65536
    ENCRYPTEDPROTECTIONTYPENOTSUPPORTEDEXCEPTION_USAGERIGHTS = 131072
    PURVIEWCLAIMSCHALLENGENOTSUPPORTEDEXCEPTION_USAGERIGHTS = 262144
    EXCEPTION_USAGERIGHTS = 524288
    UNKNOWNFUTUREVALUE_USAGERIGHTS = 1048576
)

func (i UsageRights) String() string {
    var values []string
    options := []string{"unknown", "docEdit", "edit", "comment", "export", "forward", "owner", "print", "reply", "replyAll", "view", "extract", "viewRightsData", "editRightsData", "objModel", "accessDenied", "userDefinedProtectionTypeNotSupportedException", "encryptedProtectionTypeNotSupportedException", "purviewClaimsChallengeNotSupportedException", "exception", "unknownFutureValue"}
    for p := 0; p < 21; p++ {
        mantis := UsageRights(int(math.Pow(2, float64(p))))
        if i&mantis == mantis {
            values = append(values, options[p])
        }
    }
    return strings.Join(values, ",")
}
func ParseUsageRights(v string) (any, error) {
    var result UsageRights
    values := strings.Split(v, ",")
    for _, str := range values {
        switch str {
            case "unknown":
                result |= UNKNOWN_USAGERIGHTS
            case "docEdit":
                result |= DOCEDIT_USAGERIGHTS
            case "edit":
                result |= EDIT_USAGERIGHTS
            case "comment":
                result |= COMMENT_USAGERIGHTS
            case "export":
                result |= EXPORT_USAGERIGHTS
            case "forward":
                result |= FORWARD_USAGERIGHTS
            case "owner":
                result |= OWNER_USAGERIGHTS
            case "print":
                result |= PRINT_USAGERIGHTS
            case "reply":
                result |= REPLY_USAGERIGHTS
            case "replyAll":
                result |= REPLYALL_USAGERIGHTS
            case "view":
                result |= VIEW_USAGERIGHTS
            case "extract":
                result |= EXTRACT_USAGERIGHTS
            case "viewRightsData":
                result |= VIEWRIGHTSDATA_USAGERIGHTS
            case "editRightsData":
                result |= EDITRIGHTSDATA_USAGERIGHTS
            case "objModel":
                result |= OBJMODEL_USAGERIGHTS
            case "accessDenied":
                result |= ACCESSDENIED_USAGERIGHTS
            case "userDefinedProtectionTypeNotSupportedException":
                result |= USERDEFINEDPROTECTIONTYPENOTSUPPORTEDEXCEPTION_USAGERIGHTS
            case "encryptedProtectionTypeNotSupportedException":
                result |= ENCRYPTEDPROTECTIONTYPENOTSUPPORTEDEXCEPTION_USAGERIGHTS
            case "purviewClaimsChallengeNotSupportedException":
                result |= PURVIEWCLAIMSCHALLENGENOTSUPPORTEDEXCEPTION_USAGERIGHTS
            case "exception":
                result |= EXCEPTION_USAGERIGHTS
            case "unknownFutureValue":
                result |= UNKNOWNFUTUREVALUE_USAGERIGHTS
            default:
                return nil, nil
        }
    }
    return &result, nil
}
func SerializeUsageRights(values []UsageRights) []string {
    result := make([]string, len(values))
    for i, v := range values {
        result[i] = v.String()
    }
    return result
}
func (i UsageRights) isMultiValue() bool {
    return true
}
