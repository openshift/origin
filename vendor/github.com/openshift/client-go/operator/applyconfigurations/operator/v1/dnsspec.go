// Code generated by applyconfiguration-gen. DO NOT EDIT.

package v1

import (
	operatorv1 "github.com/openshift/api/operator/v1"
)

// DNSSpecApplyConfiguration represents a declarative configuration of the DNSSpec type for use
// with apply.
//
// DNSSpec is the specification of the desired behavior of the DNS.
type DNSSpecApplyConfiguration struct {
	// servers is a list of DNS resolvers that provide name query delegation for one or
	// more subdomains outside the scope of the cluster domain. If servers consists of
	// more than one Server, longest suffix match will be used to determine the Server.
	//
	// For example, if there are two Servers, one for "foo.com" and another for "a.foo.com",
	// and the name query is for "www.a.foo.com", it will be routed to the Server with Zone
	// "a.foo.com".
	//
	// If this field is nil, no servers are created.
	Servers []ServerApplyConfiguration `json:"servers,omitempty"`
	// upstreamResolvers defines a schema for configuring CoreDNS
	// to proxy DNS messages to upstream resolvers for the case of the
	// default (".") server
	//
	// If this field is not specified, the upstream used will default to
	// /etc/resolv.conf, with policy "sequential"
	UpstreamResolvers *UpstreamResolversApplyConfiguration `json:"upstreamResolvers,omitempty"`
	// nodePlacement provides explicit control over the scheduling of DNS
	// pods.
	//
	// Generally, it is useful to run a DNS pod on every node so that DNS
	// queries are always handled by a local DNS pod instead of going over
	// the network to a DNS pod on another node.  However, security policies
	// may require restricting the placement of DNS pods to specific nodes.
	// For example, if a security policy prohibits pods on arbitrary nodes
	// from communicating with the API, a node selector can be specified to
	// restrict DNS pods to nodes that are permitted to communicate with the
	// API.  Conversely, if running DNS pods on nodes with a particular
	// taint is desired, a toleration can be specified for that taint.
	//
	// If unset, defaults are used. See nodePlacement for more details.
	NodePlacement *DNSNodePlacementApplyConfiguration `json:"nodePlacement,omitempty"`
	// managementState indicates whether the DNS operator should manage cluster
	// DNS
	ManagementState *operatorv1.ManagementState `json:"managementState,omitempty"`
	// operatorLogLevel controls the logging level of the DNS Operator.
	// Valid values are: "Normal", "Debug", "Trace".
	// Defaults to "Normal".
	// setting operatorLogLevel: Trace will produce extremely verbose logs.
	OperatorLogLevel *operatorv1.DNSLogLevel `json:"operatorLogLevel,omitempty"`
	// logLevel describes the desired logging verbosity for CoreDNS.
	// Any one of the following values may be specified:
	// * Normal logs errors from upstream resolvers.
	// * Debug logs errors, NXDOMAIN responses, and NODATA responses.
	// * Trace logs errors and all responses.
	// Setting logLevel: Trace will produce extremely verbose logs.
	// Valid values are: "Normal", "Debug", "Trace".
	// Defaults to "Normal".
	LogLevel *operatorv1.DNSLogLevel `json:"logLevel,omitempty"`
	// cache describes the caching configuration that applies to all server blocks listed in the Corefile.
	// This field allows a cluster admin to optionally configure:
	// * positiveTTL which is a duration for which positive responses should be cached.
	// * negativeTTL which is a duration for which negative responses should be cached.
	// If this is not configured, OpenShift will configure positive and negative caching with a default value that is
	// subject to change. At the time of writing, the default positiveTTL is 900 seconds and the default negativeTTL is
	// 30 seconds or as noted in the respective Corefile for your version of OpenShift.
	Cache *DNSCacheApplyConfiguration `json:"cache,omitempty"`
}

// DNSSpecApplyConfiguration constructs a declarative configuration of the DNSSpec type for use with
// apply.
func DNSSpec() *DNSSpecApplyConfiguration {
	return &DNSSpecApplyConfiguration{}
}

// WithServers adds the given value to the Servers field in the declarative configuration
// and returns the receiver, so that objects can be build by chaining "With" function invocations.
// If called multiple times, values provided by each call will be appended to the Servers field.
func (b *DNSSpecApplyConfiguration) WithServers(values ...*ServerApplyConfiguration) *DNSSpecApplyConfiguration {
	for i := range values {
		if values[i] == nil {
			panic("nil value passed to WithServers")
		}
		b.Servers = append(b.Servers, *values[i])
	}
	return b
}

// WithUpstreamResolvers sets the UpstreamResolvers field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the UpstreamResolvers field is set to the value of the last call.
func (b *DNSSpecApplyConfiguration) WithUpstreamResolvers(value *UpstreamResolversApplyConfiguration) *DNSSpecApplyConfiguration {
	b.UpstreamResolvers = value
	return b
}

// WithNodePlacement sets the NodePlacement field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the NodePlacement field is set to the value of the last call.
func (b *DNSSpecApplyConfiguration) WithNodePlacement(value *DNSNodePlacementApplyConfiguration) *DNSSpecApplyConfiguration {
	b.NodePlacement = value
	return b
}

// WithManagementState sets the ManagementState field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the ManagementState field is set to the value of the last call.
func (b *DNSSpecApplyConfiguration) WithManagementState(value operatorv1.ManagementState) *DNSSpecApplyConfiguration {
	b.ManagementState = &value
	return b
}

// WithOperatorLogLevel sets the OperatorLogLevel field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the OperatorLogLevel field is set to the value of the last call.
func (b *DNSSpecApplyConfiguration) WithOperatorLogLevel(value operatorv1.DNSLogLevel) *DNSSpecApplyConfiguration {
	b.OperatorLogLevel = &value
	return b
}

// WithLogLevel sets the LogLevel field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the LogLevel field is set to the value of the last call.
func (b *DNSSpecApplyConfiguration) WithLogLevel(value operatorv1.DNSLogLevel) *DNSSpecApplyConfiguration {
	b.LogLevel = &value
	return b
}

// WithCache sets the Cache field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the Cache field is set to the value of the last call.
func (b *DNSSpecApplyConfiguration) WithCache(value *DNSCacheApplyConfiguration) *DNSSpecApplyConfiguration {
	b.Cache = value
	return b
}
