// Code generated by applyconfiguration-gen. DO NOT EDIT.

package v1

import (
	operatorv1 "github.com/openshift/api/operator/v1"
	runtime "k8s.io/apimachinery/pkg/runtime"
)

// NetworkSpecApplyConfiguration represents a declarative configuration of the NetworkSpec type for use
// with apply.
//
// NetworkSpec is the top-level network configuration object.
type NetworkSpecApplyConfiguration struct {
	OperatorSpecApplyConfiguration `json:",inline"`
	// clusterNetwork is the IP address pool to use for pod IPs.
	// Some network providers support multiple ClusterNetworks.
	// Others only support one. This is equivalent to the cluster-cidr.
	ClusterNetwork []ClusterNetworkEntryApplyConfiguration `json:"clusterNetwork,omitempty"`
	// serviceNetwork is the ip address pool to use for Service IPs
	// Currently, all existing network providers only support a single value
	// here, but this is an array to allow for growth.
	ServiceNetwork []string `json:"serviceNetwork,omitempty"`
	// defaultNetwork is the "default" network that all pods will receive
	DefaultNetwork *DefaultNetworkDefinitionApplyConfiguration `json:"defaultNetwork,omitempty"`
	// additionalNetworks is a list of extra networks to make available to pods
	// when multiple networks are enabled.
	AdditionalNetworks []AdditionalNetworkDefinitionApplyConfiguration `json:"additionalNetworks,omitempty"`
	// disableMultiNetwork defaults to 'false' and this setting enables the pod multi-networking capability.
	// disableMultiNetwork when set to 'true' at cluster install time does not install the components, typically the Multus CNI and the network-attachment-definition CRD,
	// that enable the pod multi-networking capability. Setting the parameter to 'true' might be useful when you need install third-party CNI plugins,
	// but these plugins are not supported by Red Hat. Changing the parameter value as a postinstallation cluster task has no effect.
	DisableMultiNetwork *bool `json:"disableMultiNetwork,omitempty"`
	// useMultiNetworkPolicy enables a controller which allows for
	// MultiNetworkPolicy objects to be used on additional networks as
	// created by Multus CNI. MultiNetworkPolicy are similar to NetworkPolicy
	// objects, but NetworkPolicy objects only apply to the primary interface.
	// With MultiNetworkPolicy, you can control the traffic that a pod can receive
	// over the secondary interfaces. If unset, this property defaults to 'false'
	// and MultiNetworkPolicy objects are ignored. If 'disableMultiNetwork' is
	// 'true' then the value of this field is ignored.
	UseMultiNetworkPolicy *bool `json:"useMultiNetworkPolicy,omitempty"`
	// deployKubeProxy specifies whether or not a standalone kube-proxy should
	// be deployed by the operator. Some network providers include kube-proxy
	// or similar functionality. If unset, the plugin will attempt to select
	// the correct value, which is false when ovn-kubernetes is used and true
	// otherwise.
	DeployKubeProxy *bool `json:"deployKubeProxy,omitempty"`
	// disableNetworkDiagnostics specifies whether or not PodNetworkConnectivityCheck
	// CRs from a test pod to every node, apiserver and LB should be disabled or not.
	// If unset, this property defaults to 'false' and network diagnostics is enabled.
	// Setting this to 'true' would reduce the additional load of the pods performing the checks.
	DisableNetworkDiagnostics *bool `json:"disableNetworkDiagnostics,omitempty"`
	// kubeProxyConfig lets us configure desired proxy configuration, if
	// deployKubeProxy is true. If not specified, sensible defaults will be chosen by
	// OpenShift directly.
	KubeProxyConfig *ProxyConfigApplyConfiguration `json:"kubeProxyConfig,omitempty"`
	// exportNetworkFlows enables and configures the export of network flow metadata from the pod network
	// by using protocols NetFlow, SFlow or IPFIX. Currently only supported on OVN-Kubernetes plugin.
	// If unset, flows will not be exported to any collector.
	ExportNetworkFlows *ExportNetworkFlowsApplyConfiguration `json:"exportNetworkFlows,omitempty"`
	// migration enables and configures cluster network migration, for network changes
	// that cannot be made instantly.
	Migration *NetworkMigrationApplyConfiguration `json:"migration,omitempty"`
	// additionalRoutingCapabilities describes components and relevant
	// configuration providing additional routing capabilities. When set, it
	// enables such components and the usage of the routing capabilities they
	// provide for the machine network. Upstream operators, like MetalLB
	// operator, requiring these capabilities may rely on, or automatically set
	// this attribute. Network plugins may leverage advanced routing
	// capabilities acquired through the enablement of these components but may
	// require specific configuration on their side to do so; refer to their
	// respective documentation and configuration options.
	AdditionalRoutingCapabilities *AdditionalRoutingCapabilitiesApplyConfiguration `json:"additionalRoutingCapabilities,omitempty"`
}

// NetworkSpecApplyConfiguration constructs a declarative configuration of the NetworkSpec type for use with
// apply.
func NetworkSpec() *NetworkSpecApplyConfiguration {
	return &NetworkSpecApplyConfiguration{}
}

// WithManagementState sets the ManagementState field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the ManagementState field is set to the value of the last call.
func (b *NetworkSpecApplyConfiguration) WithManagementState(value operatorv1.ManagementState) *NetworkSpecApplyConfiguration {
	b.OperatorSpecApplyConfiguration.ManagementState = &value
	return b
}

// WithLogLevel sets the LogLevel field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the LogLevel field is set to the value of the last call.
func (b *NetworkSpecApplyConfiguration) WithLogLevel(value operatorv1.LogLevel) *NetworkSpecApplyConfiguration {
	b.OperatorSpecApplyConfiguration.LogLevel = &value
	return b
}

// WithOperatorLogLevel sets the OperatorLogLevel field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the OperatorLogLevel field is set to the value of the last call.
func (b *NetworkSpecApplyConfiguration) WithOperatorLogLevel(value operatorv1.LogLevel) *NetworkSpecApplyConfiguration {
	b.OperatorSpecApplyConfiguration.OperatorLogLevel = &value
	return b
}

// WithUnsupportedConfigOverrides sets the UnsupportedConfigOverrides field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the UnsupportedConfigOverrides field is set to the value of the last call.
func (b *NetworkSpecApplyConfiguration) WithUnsupportedConfigOverrides(value runtime.RawExtension) *NetworkSpecApplyConfiguration {
	b.OperatorSpecApplyConfiguration.UnsupportedConfigOverrides = &value
	return b
}

// WithObservedConfig sets the ObservedConfig field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the ObservedConfig field is set to the value of the last call.
func (b *NetworkSpecApplyConfiguration) WithObservedConfig(value runtime.RawExtension) *NetworkSpecApplyConfiguration {
	b.OperatorSpecApplyConfiguration.ObservedConfig = &value
	return b
}

// WithClusterNetwork adds the given value to the ClusterNetwork field in the declarative configuration
// and returns the receiver, so that objects can be build by chaining "With" function invocations.
// If called multiple times, values provided by each call will be appended to the ClusterNetwork field.
func (b *NetworkSpecApplyConfiguration) WithClusterNetwork(values ...*ClusterNetworkEntryApplyConfiguration) *NetworkSpecApplyConfiguration {
	for i := range values {
		if values[i] == nil {
			panic("nil value passed to WithClusterNetwork")
		}
		b.ClusterNetwork = append(b.ClusterNetwork, *values[i])
	}
	return b
}

// WithServiceNetwork adds the given value to the ServiceNetwork field in the declarative configuration
// and returns the receiver, so that objects can be build by chaining "With" function invocations.
// If called multiple times, values provided by each call will be appended to the ServiceNetwork field.
func (b *NetworkSpecApplyConfiguration) WithServiceNetwork(values ...string) *NetworkSpecApplyConfiguration {
	for i := range values {
		b.ServiceNetwork = append(b.ServiceNetwork, values[i])
	}
	return b
}

// WithDefaultNetwork sets the DefaultNetwork field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the DefaultNetwork field is set to the value of the last call.
func (b *NetworkSpecApplyConfiguration) WithDefaultNetwork(value *DefaultNetworkDefinitionApplyConfiguration) *NetworkSpecApplyConfiguration {
	b.DefaultNetwork = value
	return b
}

// WithAdditionalNetworks adds the given value to the AdditionalNetworks field in the declarative configuration
// and returns the receiver, so that objects can be build by chaining "With" function invocations.
// If called multiple times, values provided by each call will be appended to the AdditionalNetworks field.
func (b *NetworkSpecApplyConfiguration) WithAdditionalNetworks(values ...*AdditionalNetworkDefinitionApplyConfiguration) *NetworkSpecApplyConfiguration {
	for i := range values {
		if values[i] == nil {
			panic("nil value passed to WithAdditionalNetworks")
		}
		b.AdditionalNetworks = append(b.AdditionalNetworks, *values[i])
	}
	return b
}

// WithDisableMultiNetwork sets the DisableMultiNetwork field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the DisableMultiNetwork field is set to the value of the last call.
func (b *NetworkSpecApplyConfiguration) WithDisableMultiNetwork(value bool) *NetworkSpecApplyConfiguration {
	b.DisableMultiNetwork = &value
	return b
}

// WithUseMultiNetworkPolicy sets the UseMultiNetworkPolicy field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the UseMultiNetworkPolicy field is set to the value of the last call.
func (b *NetworkSpecApplyConfiguration) WithUseMultiNetworkPolicy(value bool) *NetworkSpecApplyConfiguration {
	b.UseMultiNetworkPolicy = &value
	return b
}

// WithDeployKubeProxy sets the DeployKubeProxy field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the DeployKubeProxy field is set to the value of the last call.
func (b *NetworkSpecApplyConfiguration) WithDeployKubeProxy(value bool) *NetworkSpecApplyConfiguration {
	b.DeployKubeProxy = &value
	return b
}

// WithDisableNetworkDiagnostics sets the DisableNetworkDiagnostics field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the DisableNetworkDiagnostics field is set to the value of the last call.
func (b *NetworkSpecApplyConfiguration) WithDisableNetworkDiagnostics(value bool) *NetworkSpecApplyConfiguration {
	b.DisableNetworkDiagnostics = &value
	return b
}

// WithKubeProxyConfig sets the KubeProxyConfig field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the KubeProxyConfig field is set to the value of the last call.
func (b *NetworkSpecApplyConfiguration) WithKubeProxyConfig(value *ProxyConfigApplyConfiguration) *NetworkSpecApplyConfiguration {
	b.KubeProxyConfig = value
	return b
}

// WithExportNetworkFlows sets the ExportNetworkFlows field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the ExportNetworkFlows field is set to the value of the last call.
func (b *NetworkSpecApplyConfiguration) WithExportNetworkFlows(value *ExportNetworkFlowsApplyConfiguration) *NetworkSpecApplyConfiguration {
	b.ExportNetworkFlows = value
	return b
}

// WithMigration sets the Migration field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the Migration field is set to the value of the last call.
func (b *NetworkSpecApplyConfiguration) WithMigration(value *NetworkMigrationApplyConfiguration) *NetworkSpecApplyConfiguration {
	b.Migration = value
	return b
}

// WithAdditionalRoutingCapabilities sets the AdditionalRoutingCapabilities field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the AdditionalRoutingCapabilities field is set to the value of the last call.
func (b *NetworkSpecApplyConfiguration) WithAdditionalRoutingCapabilities(value *AdditionalRoutingCapabilitiesApplyConfiguration) *NetworkSpecApplyConfiguration {
	b.AdditionalRoutingCapabilities = value
	return b
}
