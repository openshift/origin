// Code generated by applyconfiguration-gen. DO NOT EDIT.

package v1

import (
	networkv1 "github.com/openshift/api/network/v1"
	internal "github.com/openshift/client-go/network/applyconfigurations/internal"
	apismetav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	types "k8s.io/apimachinery/pkg/types"
	managedfields "k8s.io/apimachinery/pkg/util/managedfields"
	metav1 "k8s.io/client-go/applyconfigurations/meta/v1"
)

// ClusterNetworkApplyConfiguration represents a declarative configuration of the ClusterNetwork type for use
// with apply.
//
// ClusterNetwork was used by OpenShift SDN.
// DEPRECATED: OpenShift SDN is no longer supported and this object is no longer used in
// any way by OpenShift.
//
// Compatibility level 1: Stable within a major release for a minimum of 12 months or 3 minor releases (whichever is longer).
type ClusterNetworkApplyConfiguration struct {
	metav1.TypeMetaApplyConfiguration `json:",inline"`
	// metadata is the standard object's metadata.
	// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
	*metav1.ObjectMetaApplyConfiguration `json:"metadata,omitempty"`
	// network is a CIDR string specifying the global overlay network's L3 space
	Network *string `json:"network,omitempty"`
	// hostsubnetlength is the number of bits of network to allocate to each node. eg, 8 would mean that each node would have a /24 slice of the overlay network for its pods
	HostSubnetLength *uint32 `json:"hostsubnetlength,omitempty"`
	// serviceNetwork is the CIDR range that Service IP addresses are allocated from
	ServiceNetwork *string `json:"serviceNetwork,omitempty"`
	// pluginName is the name of the network plugin being used
	PluginName *string `json:"pluginName,omitempty"`
	// clusterNetworks is a list of ClusterNetwork objects that defines the global overlay network's L3 space by specifying a set of CIDR and netmasks that the SDN can allocate addresses from.
	ClusterNetworks []ClusterNetworkEntryApplyConfiguration `json:"clusterNetworks,omitempty"`
	// vxlanPort sets the VXLAN destination port used by the cluster.
	// It is set by the master configuration file on startup and cannot be edited manually.
	// Valid values for VXLANPort are integers 1-65535 inclusive and if unset defaults to 4789.
	// Changing VXLANPort allows users to resolve issues between openshift SDN and other software trying to use the same VXLAN destination port.
	VXLANPort *uint32 `json:"vxlanPort,omitempty"`
	// mtu is the MTU for the overlay network. This should be 50 less than the MTU of the network connecting the nodes. It is normally autodetected by the cluster network operator.
	MTU *uint32 `json:"mtu,omitempty"`
}

// ClusterNetwork constructs a declarative configuration of the ClusterNetwork type for use with
// apply.
func ClusterNetwork(name string) *ClusterNetworkApplyConfiguration {
	b := &ClusterNetworkApplyConfiguration{}
	b.WithName(name)
	b.WithKind("ClusterNetwork")
	b.WithAPIVersion("network.openshift.io/v1")
	return b
}

// ExtractClusterNetworkFrom extracts the applied configuration owned by fieldManager from
// clusterNetwork for the specified subresource. Pass an empty string for subresource to extract
// the main resource. Common subresources include "status", "scale", etc.
// clusterNetwork must be a unmodified ClusterNetwork API object that was retrieved from the Kubernetes API.
// ExtractClusterNetworkFrom provides a way to perform a extract/modify-in-place/apply workflow.
// Note that an extracted apply configuration will contain fewer fields than what the fieldManager previously
// applied if another fieldManager has updated or force applied any of the previously applied fields.
func ExtractClusterNetworkFrom(clusterNetwork *networkv1.ClusterNetwork, fieldManager string, subresource string) (*ClusterNetworkApplyConfiguration, error) {
	b := &ClusterNetworkApplyConfiguration{}
	err := managedfields.ExtractInto(clusterNetwork, internal.Parser().Type("com.github.openshift.api.network.v1.ClusterNetwork"), fieldManager, b, subresource)
	if err != nil {
		return nil, err
	}
	b.WithName(clusterNetwork.Name)

	b.WithKind("ClusterNetwork")
	b.WithAPIVersion("network.openshift.io/v1")
	return b, nil
}

// ExtractClusterNetwork extracts the applied configuration owned by fieldManager from
// clusterNetwork. If no managedFields are found in clusterNetwork for fieldManager, a
// ClusterNetworkApplyConfiguration is returned with only the Name, Namespace (if applicable),
// APIVersion and Kind populated. It is possible that no managed fields were found for because other
// field managers have taken ownership of all the fields previously owned by fieldManager, or because
// the fieldManager never owned fields any fields.
// clusterNetwork must be a unmodified ClusterNetwork API object that was retrieved from the Kubernetes API.
// ExtractClusterNetwork provides a way to perform a extract/modify-in-place/apply workflow.
// Note that an extracted apply configuration will contain fewer fields than what the fieldManager previously
// applied if another fieldManager has updated or force applied any of the previously applied fields.
func ExtractClusterNetwork(clusterNetwork *networkv1.ClusterNetwork, fieldManager string) (*ClusterNetworkApplyConfiguration, error) {
	return ExtractClusterNetworkFrom(clusterNetwork, fieldManager, "")
}

func (b ClusterNetworkApplyConfiguration) IsApplyConfiguration() {}

// WithKind sets the Kind field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the Kind field is set to the value of the last call.
func (b *ClusterNetworkApplyConfiguration) WithKind(value string) *ClusterNetworkApplyConfiguration {
	b.TypeMetaApplyConfiguration.Kind = &value
	return b
}

// WithAPIVersion sets the APIVersion field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the APIVersion field is set to the value of the last call.
func (b *ClusterNetworkApplyConfiguration) WithAPIVersion(value string) *ClusterNetworkApplyConfiguration {
	b.TypeMetaApplyConfiguration.APIVersion = &value
	return b
}

// WithName sets the Name field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the Name field is set to the value of the last call.
func (b *ClusterNetworkApplyConfiguration) WithName(value string) *ClusterNetworkApplyConfiguration {
	b.ensureObjectMetaApplyConfigurationExists()
	b.ObjectMetaApplyConfiguration.Name = &value
	return b
}

// WithGenerateName sets the GenerateName field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the GenerateName field is set to the value of the last call.
func (b *ClusterNetworkApplyConfiguration) WithGenerateName(value string) *ClusterNetworkApplyConfiguration {
	b.ensureObjectMetaApplyConfigurationExists()
	b.ObjectMetaApplyConfiguration.GenerateName = &value
	return b
}

// WithNamespace sets the Namespace field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the Namespace field is set to the value of the last call.
func (b *ClusterNetworkApplyConfiguration) WithNamespace(value string) *ClusterNetworkApplyConfiguration {
	b.ensureObjectMetaApplyConfigurationExists()
	b.ObjectMetaApplyConfiguration.Namespace = &value
	return b
}

// WithUID sets the UID field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the UID field is set to the value of the last call.
func (b *ClusterNetworkApplyConfiguration) WithUID(value types.UID) *ClusterNetworkApplyConfiguration {
	b.ensureObjectMetaApplyConfigurationExists()
	b.ObjectMetaApplyConfiguration.UID = &value
	return b
}

// WithResourceVersion sets the ResourceVersion field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the ResourceVersion field is set to the value of the last call.
func (b *ClusterNetworkApplyConfiguration) WithResourceVersion(value string) *ClusterNetworkApplyConfiguration {
	b.ensureObjectMetaApplyConfigurationExists()
	b.ObjectMetaApplyConfiguration.ResourceVersion = &value
	return b
}

// WithGeneration sets the Generation field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the Generation field is set to the value of the last call.
func (b *ClusterNetworkApplyConfiguration) WithGeneration(value int64) *ClusterNetworkApplyConfiguration {
	b.ensureObjectMetaApplyConfigurationExists()
	b.ObjectMetaApplyConfiguration.Generation = &value
	return b
}

// WithCreationTimestamp sets the CreationTimestamp field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the CreationTimestamp field is set to the value of the last call.
func (b *ClusterNetworkApplyConfiguration) WithCreationTimestamp(value apismetav1.Time) *ClusterNetworkApplyConfiguration {
	b.ensureObjectMetaApplyConfigurationExists()
	b.ObjectMetaApplyConfiguration.CreationTimestamp = &value
	return b
}

// WithDeletionTimestamp sets the DeletionTimestamp field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the DeletionTimestamp field is set to the value of the last call.
func (b *ClusterNetworkApplyConfiguration) WithDeletionTimestamp(value apismetav1.Time) *ClusterNetworkApplyConfiguration {
	b.ensureObjectMetaApplyConfigurationExists()
	b.ObjectMetaApplyConfiguration.DeletionTimestamp = &value
	return b
}

// WithDeletionGracePeriodSeconds sets the DeletionGracePeriodSeconds field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the DeletionGracePeriodSeconds field is set to the value of the last call.
func (b *ClusterNetworkApplyConfiguration) WithDeletionGracePeriodSeconds(value int64) *ClusterNetworkApplyConfiguration {
	b.ensureObjectMetaApplyConfigurationExists()
	b.ObjectMetaApplyConfiguration.DeletionGracePeriodSeconds = &value
	return b
}

// WithLabels puts the entries into the Labels field in the declarative configuration
// and returns the receiver, so that objects can be build by chaining "With" function invocations.
// If called multiple times, the entries provided by each call will be put on the Labels field,
// overwriting an existing map entries in Labels field with the same key.
func (b *ClusterNetworkApplyConfiguration) WithLabels(entries map[string]string) *ClusterNetworkApplyConfiguration {
	b.ensureObjectMetaApplyConfigurationExists()
	if b.ObjectMetaApplyConfiguration.Labels == nil && len(entries) > 0 {
		b.ObjectMetaApplyConfiguration.Labels = make(map[string]string, len(entries))
	}
	for k, v := range entries {
		b.ObjectMetaApplyConfiguration.Labels[k] = v
	}
	return b
}

// WithAnnotations puts the entries into the Annotations field in the declarative configuration
// and returns the receiver, so that objects can be build by chaining "With" function invocations.
// If called multiple times, the entries provided by each call will be put on the Annotations field,
// overwriting an existing map entries in Annotations field with the same key.
func (b *ClusterNetworkApplyConfiguration) WithAnnotations(entries map[string]string) *ClusterNetworkApplyConfiguration {
	b.ensureObjectMetaApplyConfigurationExists()
	if b.ObjectMetaApplyConfiguration.Annotations == nil && len(entries) > 0 {
		b.ObjectMetaApplyConfiguration.Annotations = make(map[string]string, len(entries))
	}
	for k, v := range entries {
		b.ObjectMetaApplyConfiguration.Annotations[k] = v
	}
	return b
}

// WithOwnerReferences adds the given value to the OwnerReferences field in the declarative configuration
// and returns the receiver, so that objects can be build by chaining "With" function invocations.
// If called multiple times, values provided by each call will be appended to the OwnerReferences field.
func (b *ClusterNetworkApplyConfiguration) WithOwnerReferences(values ...*metav1.OwnerReferenceApplyConfiguration) *ClusterNetworkApplyConfiguration {
	b.ensureObjectMetaApplyConfigurationExists()
	for i := range values {
		if values[i] == nil {
			panic("nil value passed to WithOwnerReferences")
		}
		b.ObjectMetaApplyConfiguration.OwnerReferences = append(b.ObjectMetaApplyConfiguration.OwnerReferences, *values[i])
	}
	return b
}

// WithFinalizers adds the given value to the Finalizers field in the declarative configuration
// and returns the receiver, so that objects can be build by chaining "With" function invocations.
// If called multiple times, values provided by each call will be appended to the Finalizers field.
func (b *ClusterNetworkApplyConfiguration) WithFinalizers(values ...string) *ClusterNetworkApplyConfiguration {
	b.ensureObjectMetaApplyConfigurationExists()
	for i := range values {
		b.ObjectMetaApplyConfiguration.Finalizers = append(b.ObjectMetaApplyConfiguration.Finalizers, values[i])
	}
	return b
}

func (b *ClusterNetworkApplyConfiguration) ensureObjectMetaApplyConfigurationExists() {
	if b.ObjectMetaApplyConfiguration == nil {
		b.ObjectMetaApplyConfiguration = &metav1.ObjectMetaApplyConfiguration{}
	}
}

// WithNetwork sets the Network field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the Network field is set to the value of the last call.
func (b *ClusterNetworkApplyConfiguration) WithNetwork(value string) *ClusterNetworkApplyConfiguration {
	b.Network = &value
	return b
}

// WithHostSubnetLength sets the HostSubnetLength field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the HostSubnetLength field is set to the value of the last call.
func (b *ClusterNetworkApplyConfiguration) WithHostSubnetLength(value uint32) *ClusterNetworkApplyConfiguration {
	b.HostSubnetLength = &value
	return b
}

// WithServiceNetwork sets the ServiceNetwork field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the ServiceNetwork field is set to the value of the last call.
func (b *ClusterNetworkApplyConfiguration) WithServiceNetwork(value string) *ClusterNetworkApplyConfiguration {
	b.ServiceNetwork = &value
	return b
}

// WithPluginName sets the PluginName field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the PluginName field is set to the value of the last call.
func (b *ClusterNetworkApplyConfiguration) WithPluginName(value string) *ClusterNetworkApplyConfiguration {
	b.PluginName = &value
	return b
}

// WithClusterNetworks adds the given value to the ClusterNetworks field in the declarative configuration
// and returns the receiver, so that objects can be build by chaining "With" function invocations.
// If called multiple times, values provided by each call will be appended to the ClusterNetworks field.
func (b *ClusterNetworkApplyConfiguration) WithClusterNetworks(values ...*ClusterNetworkEntryApplyConfiguration) *ClusterNetworkApplyConfiguration {
	for i := range values {
		if values[i] == nil {
			panic("nil value passed to WithClusterNetworks")
		}
		b.ClusterNetworks = append(b.ClusterNetworks, *values[i])
	}
	return b
}

// WithVXLANPort sets the VXLANPort field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the VXLANPort field is set to the value of the last call.
func (b *ClusterNetworkApplyConfiguration) WithVXLANPort(value uint32) *ClusterNetworkApplyConfiguration {
	b.VXLANPort = &value
	return b
}

// WithMTU sets the MTU field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the MTU field is set to the value of the last call.
func (b *ClusterNetworkApplyConfiguration) WithMTU(value uint32) *ClusterNetworkApplyConfiguration {
	b.MTU = &value
	return b
}

// GetKind retrieves the value of the Kind field in the declarative configuration.
func (b *ClusterNetworkApplyConfiguration) GetKind() *string {
	return b.TypeMetaApplyConfiguration.Kind
}

// GetAPIVersion retrieves the value of the APIVersion field in the declarative configuration.
func (b *ClusterNetworkApplyConfiguration) GetAPIVersion() *string {
	return b.TypeMetaApplyConfiguration.APIVersion
}

// GetName retrieves the value of the Name field in the declarative configuration.
func (b *ClusterNetworkApplyConfiguration) GetName() *string {
	b.ensureObjectMetaApplyConfigurationExists()
	return b.ObjectMetaApplyConfiguration.Name
}

// GetNamespace retrieves the value of the Namespace field in the declarative configuration.
func (b *ClusterNetworkApplyConfiguration) GetNamespace() *string {
	b.ensureObjectMetaApplyConfigurationExists()
	return b.ObjectMetaApplyConfiguration.Namespace
}
