// Code generated by applyconfiguration-gen. DO NOT EDIT.

package v1

import (
	configv1 "github.com/openshift/api/config/v1"
)

// ClusterVersionSpecApplyConfiguration represents a declarative configuration of the ClusterVersionSpec type for use
// with apply.
//
// ClusterVersionSpec is the desired version state of the cluster. It includes
// the version the cluster should be at, how the cluster is identified, and
// where the cluster should look for version updates.
type ClusterVersionSpecApplyConfiguration struct {
	// clusterID uniquely identifies this cluster. This is expected to be
	// an RFC4122 UUID value (xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx in
	// hexadecimal values). This is a required field.
	ClusterID *configv1.ClusterID `json:"clusterID,omitempty"`
	// desiredUpdate is an optional field that indicates the desired value of
	// the cluster version. Setting this value will trigger an upgrade (if
	// the current version does not match the desired version). The set of
	// recommended update values is listed as part of available updates in
	// status, and setting values outside that range may cause the upgrade
	// to fail.
	//
	// Some of the fields are inter-related with restrictions and meanings described here.
	// 1. image is specified, version is specified, architecture is specified. API validation error.
	// 2. image is specified, version is specified, architecture is not specified. The version extracted from the referenced image must match the specified version.
	// 3. image is specified, version is not specified, architecture is specified. API validation error.
	// 4. image is specified, version is not specified, architecture is not specified. image is used.
	// 5. image is not specified, version is specified, architecture is specified. version and desired architecture are used to select an image.
	// 6. image is not specified, version is specified, architecture is not specified. version and current architecture are used to select an image.
	// 7. image is not specified, version is not specified, architecture is specified. API validation error.
	// 8. image is not specified, version is not specified, architecture is not specified. API validation error.
	//
	// If an upgrade fails the operator will halt and report status
	// about the failing component. Setting the desired update value back to
	// the previous version will cause a rollback to be attempted if the
	// previous version is within the current minor version. Not all
	// rollbacks will succeed, and some may unrecoverably break the
	// cluster.
	DesiredUpdate *UpdateApplyConfiguration `json:"desiredUpdate,omitempty"`
	// upstream may be used to specify the preferred update server. By default
	// it will use the appropriate update server for the cluster and region.
	Upstream *configv1.URL `json:"upstream,omitempty"`
	// channel is an identifier for explicitly requesting a non-default set
	// of updates to be applied to this cluster. The default channel will
	// contain stable updates that are appropriate for production clusters.
	Channel *string `json:"channel,omitempty"`
	// capabilities configures the installation of optional, core
	// cluster components.  A null value here is identical to an
	// empty object; see the child properties for default semantics.
	Capabilities *ClusterVersionCapabilitiesSpecApplyConfiguration `json:"capabilities,omitempty"`
	// signatureStores contains the upstream URIs to verify release signatures and optional
	// reference to a config map by name containing the PEM-encoded CA bundle.
	//
	// By default, CVO will use existing signature stores if this property is empty.
	// The CVO will check the release signatures in the local ConfigMaps first. It will search for a valid signature
	// in these stores in parallel only when local ConfigMaps did not include a valid signature.
	// Validation will fail if none of the signature stores reply with valid signature before timeout.
	// Setting signatureStores will replace the default signature stores with custom signature stores.
	// Default stores can be used with custom signature stores by adding them manually.
	//
	// A maximum of 32 signature stores may be configured.
	SignatureStores []SignatureStoreApplyConfiguration `json:"signatureStores,omitempty"`
	// overrides is list of overides for components that are managed by
	// cluster version operator. Marking a component unmanaged will prevent
	// the operator from creating or updating the object.
	Overrides []ComponentOverrideApplyConfiguration `json:"overrides,omitempty"`
}

// ClusterVersionSpecApplyConfiguration constructs a declarative configuration of the ClusterVersionSpec type for use with
// apply.
func ClusterVersionSpec() *ClusterVersionSpecApplyConfiguration {
	return &ClusterVersionSpecApplyConfiguration{}
}

// WithClusterID sets the ClusterID field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the ClusterID field is set to the value of the last call.
func (b *ClusterVersionSpecApplyConfiguration) WithClusterID(value configv1.ClusterID) *ClusterVersionSpecApplyConfiguration {
	b.ClusterID = &value
	return b
}

// WithDesiredUpdate sets the DesiredUpdate field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the DesiredUpdate field is set to the value of the last call.
func (b *ClusterVersionSpecApplyConfiguration) WithDesiredUpdate(value *UpdateApplyConfiguration) *ClusterVersionSpecApplyConfiguration {
	b.DesiredUpdate = value
	return b
}

// WithUpstream sets the Upstream field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the Upstream field is set to the value of the last call.
func (b *ClusterVersionSpecApplyConfiguration) WithUpstream(value configv1.URL) *ClusterVersionSpecApplyConfiguration {
	b.Upstream = &value
	return b
}

// WithChannel sets the Channel field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the Channel field is set to the value of the last call.
func (b *ClusterVersionSpecApplyConfiguration) WithChannel(value string) *ClusterVersionSpecApplyConfiguration {
	b.Channel = &value
	return b
}

// WithCapabilities sets the Capabilities field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the Capabilities field is set to the value of the last call.
func (b *ClusterVersionSpecApplyConfiguration) WithCapabilities(value *ClusterVersionCapabilitiesSpecApplyConfiguration) *ClusterVersionSpecApplyConfiguration {
	b.Capabilities = value
	return b
}

// WithSignatureStores adds the given value to the SignatureStores field in the declarative configuration
// and returns the receiver, so that objects can be build by chaining "With" function invocations.
// If called multiple times, values provided by each call will be appended to the SignatureStores field.
func (b *ClusterVersionSpecApplyConfiguration) WithSignatureStores(values ...*SignatureStoreApplyConfiguration) *ClusterVersionSpecApplyConfiguration {
	for i := range values {
		if values[i] == nil {
			panic("nil value passed to WithSignatureStores")
		}
		b.SignatureStores = append(b.SignatureStores, *values[i])
	}
	return b
}

// WithOverrides adds the given value to the Overrides field in the declarative configuration
// and returns the receiver, so that objects can be build by chaining "With" function invocations.
// If called multiple times, values provided by each call will be appended to the Overrides field.
func (b *ClusterVersionSpecApplyConfiguration) WithOverrides(values ...*ComponentOverrideApplyConfiguration) *ClusterVersionSpecApplyConfiguration {
	for i := range values {
		if values[i] == nil {
			panic("nil value passed to WithOverrides")
		}
		b.Overrides = append(b.Overrides, *values[i])
	}
	return b
}
