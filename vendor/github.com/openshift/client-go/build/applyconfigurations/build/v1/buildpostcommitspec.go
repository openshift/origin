// Code generated by applyconfiguration-gen. DO NOT EDIT.

package v1

// BuildPostCommitSpecApplyConfiguration represents a declarative configuration of the BuildPostCommitSpec type for use
// with apply.
//
// A BuildPostCommitSpec holds a build post commit hook specification. The hook
// executes a command in a temporary container running the build output image,
// immediately after the last layer of the image is committed and before the
// image is pushed to a registry. The command is executed with the current
// working directory ($PWD) set to the image's WORKDIR.
//
// The build will be marked as failed if the hook execution fails. It will fail
// if the script or command return a non-zero exit code, or if there is any
// other error related to starting the temporary container.
//
// There are five different ways to configure the hook. As an example, all forms
// below are equivalent and will execute `rake test --verbose`.
//
// 1. Shell script:
//
// "postCommit": {
// "script": "rake test --verbose",
// }
//
// The above is a convenient form which is equivalent to:
//
// "postCommit": {
// "command": ["/bin/sh", "-ic"],
// "args":    ["rake test --verbose"]
// }
//
// 2. A command as the image entrypoint:
//
// "postCommit": {
// "commit": ["rake", "test", "--verbose"]
// }
//
// Command overrides the image entrypoint in the exec form, as documented in
// Docker: https://docs.docker.com/engine/reference/builder/#entrypoint.
//
// 3. Pass arguments to the default entrypoint:
//
// "postCommit": {
// "args": ["rake", "test", "--verbose"]
// }
//
// This form is only useful if the image entrypoint can handle arguments.
//
// 4. Shell script with arguments:
//
// "postCommit": {
// "script": "rake test $1",
// "args":   ["--verbose"]
// }
//
// This form is useful if you need to pass arguments that would otherwise be
// hard to quote properly in the shell script. In the script, $0 will be
// "/bin/sh" and $1, $2, etc, are the positional arguments from Args.
//
// 5. Command with arguments:
//
// "postCommit": {
// "command": ["rake", "test"],
// "args":    ["--verbose"]
// }
//
// This form is equivalent to appending the arguments to the Command slice.
//
// It is invalid to provide both Script and Command simultaneously. If none of
// the fields are specified, the hook is not executed.
type BuildPostCommitSpecApplyConfiguration struct {
	// command is the command to run. It may not be specified with Script.
	// This might be needed if the image doesn't have `/bin/sh`, or if you
	// do not want to use a shell. In all other cases, using Script might be
	// more convenient.
	Command []string `json:"command,omitempty"`
	// args is a list of arguments that are provided to either Command,
	// Script or the container image's default entrypoint. The arguments are
	// placed immediately after the command to be run.
	Args []string `json:"args,omitempty"`
	// script is a shell script to be run with `/bin/sh -ic`. It may not be
	// specified with Command. Use Script when a shell script is appropriate
	// to execute the post build hook, for example for running unit tests
	// with `rake test`. If you need control over the image entrypoint, or
	// if the image does not have `/bin/sh`, use Command and/or Args.
	// The `-i` flag is needed to support CentOS and RHEL images that use
	// Software Collections (SCL), in order to have the appropriate
	// collections enabled in the shell. E.g., in the Ruby image, this is
	// necessary to make `ruby`, `bundle` and other binaries available in
	// the PATH.
	Script *string `json:"script,omitempty"`
}

// BuildPostCommitSpecApplyConfiguration constructs a declarative configuration of the BuildPostCommitSpec type for use with
// apply.
func BuildPostCommitSpec() *BuildPostCommitSpecApplyConfiguration {
	return &BuildPostCommitSpecApplyConfiguration{}
}

// WithCommand adds the given value to the Command field in the declarative configuration
// and returns the receiver, so that objects can be build by chaining "With" function invocations.
// If called multiple times, values provided by each call will be appended to the Command field.
func (b *BuildPostCommitSpecApplyConfiguration) WithCommand(values ...string) *BuildPostCommitSpecApplyConfiguration {
	for i := range values {
		b.Command = append(b.Command, values[i])
	}
	return b
}

// WithArgs adds the given value to the Args field in the declarative configuration
// and returns the receiver, so that objects can be build by chaining "With" function invocations.
// If called multiple times, values provided by each call will be appended to the Args field.
func (b *BuildPostCommitSpecApplyConfiguration) WithArgs(values ...string) *BuildPostCommitSpecApplyConfiguration {
	for i := range values {
		b.Args = append(b.Args, values[i])
	}
	return b
}

// WithScript sets the Script field in the declarative configuration to the given value
// and returns the receiver, so that objects can be built by chaining "With" function invocations.
// If called multiple times, the Script field is set to the value of the last call.
func (b *BuildPostCommitSpecApplyConfiguration) WithScript(value string) *BuildPostCommitSpecApplyConfiguration {
	b.Script = &value
	return b
}
