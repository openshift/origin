// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// Network network
//
// swagger:model Network
type Network struct {

	// access config
	AccessConfig AccessConfig `json:"accessConfig,omitempty"`

	// Indicates if the network is advertised externally of the workspace to PER and\or peer networks.
	// Enum: ["enable","disable"]
	Advertise string `json:"advertise,omitempty"`

	// Indicates if the ARP broadcast is enabled
	// Enum: ["enable","disable"]
	ArpBroadcast string `json:"arpBroadcast,omitempty"`

	// Network in CIDR notation (192.168.0.0/24)
	// Required: true
	Cidr *string `json:"cidr"`

	// (currently not available) cloud connections this network is attached
	CloudConnections []*NetworkCloudConnectionsItems0 `json:"cloudConnections,omitempty"`

	// The CRN for this resource
	Crn string `json:"crn,omitempty"`

	// DHCP Managed Network
	DhcpManaged bool `json:"dhcpManaged,omitempty"`

	// DNS Servers
	// Required: true
	DNSServers []string `json:"dnsServers"`

	// Gateway IP Address
	Gateway string `json:"gateway,omitempty"`

	// ip address metrics
	// Required: true
	IPAddressMetrics *NetworkIPAddressMetrics `json:"ipAddressMetrics"`

	// IP Address Ranges
	// Required: true
	IPAddressRanges []*IPAddressRange `json:"ipAddressRanges"`

	// (deprecated - replaced by mtu) Enable MTU Jumbo Network (for multi-zone locations only)
	Jumbo bool `json:"jumbo,omitempty"`

	// Maximum transmission unit
	// Maximum: 9000
	// Minimum: 1450
	Mtu *int64 `json:"mtu,omitempty"`

	// Network Name
	// Required: true
	Name *string `json:"name"`

	// network address translation
	NetworkAddressTranslation *NetworkAddressTranslation `json:"networkAddressTranslation,omitempty"`

	// Unique Network ID
	// Required: true
	NetworkID *string `json:"networkID"`

	// Network Peer ID
	PeerID string `json:"peerID,omitempty"`

	// Public IP Address Ranges (for pub-vlan networks)
	PublicIPAddressRanges []*IPAddressRange `json:"publicIPAddressRanges,omitempty"`

	// Type of Network - 'vlan' (private network) 'pub-vlan' (public network) 'dhcp-vlan' (for satellite locations only)
	// Required: true
	// Enum: ["vlan","pub-vlan","dhcp-vlan"]
	Type *string `json:"type"`

	// The user tags associated with this resource.
	UserTags []string `json:"userTags,omitempty"`

	// VLAN ID
	// Required: true
	VlanID *float64 `json:"vlanID"`
}

// Validate validates this network
func (m *Network) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAccessConfig(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAdvertise(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateArpBroadcast(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCidr(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateCloudConnections(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateDNSServers(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIPAddressMetrics(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIPAddressRanges(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMtu(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNetworkAddressTranslation(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateNetworkID(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePublicIPAddressRanges(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateType(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVlanID(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Network) validateAccessConfig(formats strfmt.Registry) error {
	if swag.IsZero(m.AccessConfig) { // not required
		return nil
	}

	if err := m.AccessConfig.Validate(formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("accessConfig")
		} else if ce, ok := err.(*errors.CompositeError); ok {
			return ce.ValidateName("accessConfig")
		}
		return err
	}

	return nil
}

var networkTypeAdvertisePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["enable","disable"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		networkTypeAdvertisePropEnum = append(networkTypeAdvertisePropEnum, v)
	}
}

const (

	// NetworkAdvertiseEnable captures enum value "enable"
	NetworkAdvertiseEnable string = "enable"

	// NetworkAdvertiseDisable captures enum value "disable"
	NetworkAdvertiseDisable string = "disable"
)

// prop value enum
func (m *Network) validateAdvertiseEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, networkTypeAdvertisePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *Network) validateAdvertise(formats strfmt.Registry) error {
	if swag.IsZero(m.Advertise) { // not required
		return nil
	}

	// value enum
	if err := m.validateAdvertiseEnum("advertise", "body", m.Advertise); err != nil {
		return err
	}

	return nil
}

var networkTypeArpBroadcastPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["enable","disable"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		networkTypeArpBroadcastPropEnum = append(networkTypeArpBroadcastPropEnum, v)
	}
}

const (

	// NetworkArpBroadcastEnable captures enum value "enable"
	NetworkArpBroadcastEnable string = "enable"

	// NetworkArpBroadcastDisable captures enum value "disable"
	NetworkArpBroadcastDisable string = "disable"
)

// prop value enum
func (m *Network) validateArpBroadcastEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, networkTypeArpBroadcastPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *Network) validateArpBroadcast(formats strfmt.Registry) error {
	if swag.IsZero(m.ArpBroadcast) { // not required
		return nil
	}

	// value enum
	if err := m.validateArpBroadcastEnum("arpBroadcast", "body", m.ArpBroadcast); err != nil {
		return err
	}

	return nil
}

func (m *Network) validateCidr(formats strfmt.Registry) error {

	if err := validate.Required("cidr", "body", m.Cidr); err != nil {
		return err
	}

	return nil
}

func (m *Network) validateCloudConnections(formats strfmt.Registry) error {
	if swag.IsZero(m.CloudConnections) { // not required
		return nil
	}

	for i := 0; i < len(m.CloudConnections); i++ {
		if swag.IsZero(m.CloudConnections[i]) { // not required
			continue
		}

		if m.CloudConnections[i] != nil {
			if err := m.CloudConnections[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("cloudConnections" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("cloudConnections" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Network) validateDNSServers(formats strfmt.Registry) error {

	if err := validate.Required("dnsServers", "body", m.DNSServers); err != nil {
		return err
	}

	return nil
}

func (m *Network) validateIPAddressMetrics(formats strfmt.Registry) error {

	if err := validate.Required("ipAddressMetrics", "body", m.IPAddressMetrics); err != nil {
		return err
	}

	if m.IPAddressMetrics != nil {
		if err := m.IPAddressMetrics.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ipAddressMetrics")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("ipAddressMetrics")
			}
			return err
		}
	}

	return nil
}

func (m *Network) validateIPAddressRanges(formats strfmt.Registry) error {

	if err := validate.Required("ipAddressRanges", "body", m.IPAddressRanges); err != nil {
		return err
	}

	for i := 0; i < len(m.IPAddressRanges); i++ {
		if swag.IsZero(m.IPAddressRanges[i]) { // not required
			continue
		}

		if m.IPAddressRanges[i] != nil {
			if err := m.IPAddressRanges[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("ipAddressRanges" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("ipAddressRanges" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Network) validateMtu(formats strfmt.Registry) error {
	if swag.IsZero(m.Mtu) { // not required
		return nil
	}

	if err := validate.MinimumInt("mtu", "body", *m.Mtu, 1450, false); err != nil {
		return err
	}

	if err := validate.MaximumInt("mtu", "body", *m.Mtu, 9000, false); err != nil {
		return err
	}

	return nil
}

func (m *Network) validateName(formats strfmt.Registry) error {

	if err := validate.Required("name", "body", m.Name); err != nil {
		return err
	}

	return nil
}

func (m *Network) validateNetworkAddressTranslation(formats strfmt.Registry) error {
	if swag.IsZero(m.NetworkAddressTranslation) { // not required
		return nil
	}

	if m.NetworkAddressTranslation != nil {
		if err := m.NetworkAddressTranslation.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("networkAddressTranslation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("networkAddressTranslation")
			}
			return err
		}
	}

	return nil
}

func (m *Network) validateNetworkID(formats strfmt.Registry) error {

	if err := validate.Required("networkID", "body", m.NetworkID); err != nil {
		return err
	}

	return nil
}

func (m *Network) validatePublicIPAddressRanges(formats strfmt.Registry) error {
	if swag.IsZero(m.PublicIPAddressRanges) { // not required
		return nil
	}

	for i := 0; i < len(m.PublicIPAddressRanges); i++ {
		if swag.IsZero(m.PublicIPAddressRanges[i]) { // not required
			continue
		}

		if m.PublicIPAddressRanges[i] != nil {
			if err := m.PublicIPAddressRanges[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("publicIPAddressRanges" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("publicIPAddressRanges" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

var networkTypeTypePropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["vlan","pub-vlan","dhcp-vlan"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		networkTypeTypePropEnum = append(networkTypeTypePropEnum, v)
	}
}

const (

	// NetworkTypeVlan captures enum value "vlan"
	NetworkTypeVlan string = "vlan"

	// NetworkTypePubDashVlan captures enum value "pub-vlan"
	NetworkTypePubDashVlan string = "pub-vlan"

	// NetworkTypeDhcpDashVlan captures enum value "dhcp-vlan"
	NetworkTypeDhcpDashVlan string = "dhcp-vlan"
)

// prop value enum
func (m *Network) validateTypeEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, networkTypeTypePropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *Network) validateType(formats strfmt.Registry) error {

	if err := validate.Required("type", "body", m.Type); err != nil {
		return err
	}

	// value enum
	if err := m.validateTypeEnum("type", "body", *m.Type); err != nil {
		return err
	}

	return nil
}

func (m *Network) validateVlanID(formats strfmt.Registry) error {

	if err := validate.Required("vlanID", "body", m.VlanID); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this network based on the context it is used
func (m *Network) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateAccessConfig(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateCloudConnections(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateIPAddressMetrics(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateIPAddressRanges(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateNetworkAddressTranslation(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidatePublicIPAddressRanges(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Network) contextValidateAccessConfig(ctx context.Context, formats strfmt.Registry) error {

	if swag.IsZero(m.AccessConfig) { // not required
		return nil
	}

	if err := m.AccessConfig.ContextValidate(ctx, formats); err != nil {
		if ve, ok := err.(*errors.Validation); ok {
			return ve.ValidateName("accessConfig")
		} else if ce, ok := err.(*errors.CompositeError); ok {
			return ce.ValidateName("accessConfig")
		}
		return err
	}

	return nil
}

func (m *Network) contextValidateCloudConnections(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.CloudConnections); i++ {

		if m.CloudConnections[i] != nil {

			if swag.IsZero(m.CloudConnections[i]) { // not required
				return nil
			}

			if err := m.CloudConnections[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("cloudConnections" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("cloudConnections" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Network) contextValidateIPAddressMetrics(ctx context.Context, formats strfmt.Registry) error {

	if m.IPAddressMetrics != nil {

		if err := m.IPAddressMetrics.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("ipAddressMetrics")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("ipAddressMetrics")
			}
			return err
		}
	}

	return nil
}

func (m *Network) contextValidateIPAddressRanges(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.IPAddressRanges); i++ {

		if m.IPAddressRanges[i] != nil {

			if swag.IsZero(m.IPAddressRanges[i]) { // not required
				return nil
			}

			if err := m.IPAddressRanges[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("ipAddressRanges" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("ipAddressRanges" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

func (m *Network) contextValidateNetworkAddressTranslation(ctx context.Context, formats strfmt.Registry) error {

	if m.NetworkAddressTranslation != nil {

		if swag.IsZero(m.NetworkAddressTranslation) { // not required
			return nil
		}

		if err := m.NetworkAddressTranslation.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("networkAddressTranslation")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("networkAddressTranslation")
			}
			return err
		}
	}

	return nil
}

func (m *Network) contextValidatePublicIPAddressRanges(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.PublicIPAddressRanges); i++ {

		if m.PublicIPAddressRanges[i] != nil {

			if swag.IsZero(m.PublicIPAddressRanges[i]) { // not required
				return nil
			}

			if err := m.PublicIPAddressRanges[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("publicIPAddressRanges" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("publicIPAddressRanges" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *Network) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *Network) UnmarshalBinary(b []byte) error {
	var res Network
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// NetworkCloudConnectionsItems0 network cloud connections items0
//
// swagger:model NetworkCloudConnectionsItems0
type NetworkCloudConnectionsItems0 struct {

	// the cloud connection id
	CloudConnectionID string `json:"cloudConnectionID,omitempty"`

	// link to the cloud connection resource
	Href string `json:"href,omitempty"`
}

// Validate validates this network cloud connections items0
func (m *NetworkCloudConnectionsItems0) Validate(formats strfmt.Registry) error {
	return nil
}

// ContextValidate validates this network cloud connections items0 based on context it is used
func (m *NetworkCloudConnectionsItems0) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *NetworkCloudConnectionsItems0) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *NetworkCloudConnectionsItems0) UnmarshalBinary(b []byte) error {
	var res NetworkCloudConnectionsItems0
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// NetworkIPAddressMetrics IP Address Metrics
//
// swagger:model NetworkIPAddressMetrics
type NetworkIPAddressMetrics struct {

	// Number of available IP addresses
	// Required: true
	Available *float64 `json:"available"`

	// Total number of all IP addresses in all ipAddressRanges
	// Required: true
	Total *float64 `json:"total"`

	// Number of IP addresses currently in use
	// Required: true
	Used *float64 `json:"used"`

	// Utilization of IP addresses in percent form (used / total) [0 - 100]
	// Required: true
	Utilization *float64 `json:"utilization"`
}

// Validate validates this network IP address metrics
func (m *NetworkIPAddressMetrics) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateAvailable(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateTotal(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUsed(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateUtilization(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *NetworkIPAddressMetrics) validateAvailable(formats strfmt.Registry) error {

	if err := validate.Required("ipAddressMetrics"+"."+"available", "body", m.Available); err != nil {
		return err
	}

	return nil
}

func (m *NetworkIPAddressMetrics) validateTotal(formats strfmt.Registry) error {

	if err := validate.Required("ipAddressMetrics"+"."+"total", "body", m.Total); err != nil {
		return err
	}

	return nil
}

func (m *NetworkIPAddressMetrics) validateUsed(formats strfmt.Registry) error {

	if err := validate.Required("ipAddressMetrics"+"."+"used", "body", m.Used); err != nil {
		return err
	}

	return nil
}

func (m *NetworkIPAddressMetrics) validateUtilization(formats strfmt.Registry) error {

	if err := validate.Required("ipAddressMetrics"+"."+"utilization", "body", m.Utilization); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this network IP address metrics based on context it is used
func (m *NetworkIPAddressMetrics) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *NetworkIPAddressMetrics) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *NetworkIPAddressMetrics) UnmarshalBinary(b []byte) error {
	var res NetworkIPAddressMetrics
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
