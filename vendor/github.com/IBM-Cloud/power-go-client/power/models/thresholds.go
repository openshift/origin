// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
)

// Thresholds storage threshold settings
//
// swagger:model Thresholds
type Thresholds struct {

	// capacity threshold
	Capacity *StorageEntities `json:"capacity,omitempty"`

	// overcommt threshold
	Overcommit *StorageEntities `json:"overcommit,omitempty"`

	// physical capacity threshold
	PhysicalCapacity *StorageEntities `json:"physicalCapacity,omitempty"`

	// vdisk capacity threshold
	VdiskCapacity *StorageEntities `json:"vdiskCapacity,omitempty"`

	// vdisk limit threshold
	VdiskLimit *StorageEntities `json:"vdiskLimit,omitempty"`
}

// Validate validates this thresholds
func (m *Thresholds) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateCapacity(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOvercommit(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePhysicalCapacity(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVdiskCapacity(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVdiskLimit(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Thresholds) validateCapacity(formats strfmt.Registry) error {
	if swag.IsZero(m.Capacity) { // not required
		return nil
	}

	if m.Capacity != nil {
		if err := m.Capacity.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("capacity")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("capacity")
			}
			return err
		}
	}

	return nil
}

func (m *Thresholds) validateOvercommit(formats strfmt.Registry) error {
	if swag.IsZero(m.Overcommit) { // not required
		return nil
	}

	if m.Overcommit != nil {
		if err := m.Overcommit.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("overcommit")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("overcommit")
			}
			return err
		}
	}

	return nil
}

func (m *Thresholds) validatePhysicalCapacity(formats strfmt.Registry) error {
	if swag.IsZero(m.PhysicalCapacity) { // not required
		return nil
	}

	if m.PhysicalCapacity != nil {
		if err := m.PhysicalCapacity.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("physicalCapacity")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("physicalCapacity")
			}
			return err
		}
	}

	return nil
}

func (m *Thresholds) validateVdiskCapacity(formats strfmt.Registry) error {
	if swag.IsZero(m.VdiskCapacity) { // not required
		return nil
	}

	if m.VdiskCapacity != nil {
		if err := m.VdiskCapacity.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("vdiskCapacity")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("vdiskCapacity")
			}
			return err
		}
	}

	return nil
}

func (m *Thresholds) validateVdiskLimit(formats strfmt.Registry) error {
	if swag.IsZero(m.VdiskLimit) { // not required
		return nil
	}

	if m.VdiskLimit != nil {
		if err := m.VdiskLimit.Validate(formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("vdiskLimit")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("vdiskLimit")
			}
			return err
		}
	}

	return nil
}

// ContextValidate validate this thresholds based on the context it is used
func (m *Thresholds) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateCapacity(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateOvercommit(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidatePhysicalCapacity(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateVdiskCapacity(ctx, formats); err != nil {
		res = append(res, err)
	}

	if err := m.contextValidateVdiskLimit(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *Thresholds) contextValidateCapacity(ctx context.Context, formats strfmt.Registry) error {

	if m.Capacity != nil {

		if swag.IsZero(m.Capacity) { // not required
			return nil
		}

		if err := m.Capacity.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("capacity")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("capacity")
			}
			return err
		}
	}

	return nil
}

func (m *Thresholds) contextValidateOvercommit(ctx context.Context, formats strfmt.Registry) error {

	if m.Overcommit != nil {

		if swag.IsZero(m.Overcommit) { // not required
			return nil
		}

		if err := m.Overcommit.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("overcommit")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("overcommit")
			}
			return err
		}
	}

	return nil
}

func (m *Thresholds) contextValidatePhysicalCapacity(ctx context.Context, formats strfmt.Registry) error {

	if m.PhysicalCapacity != nil {

		if swag.IsZero(m.PhysicalCapacity) { // not required
			return nil
		}

		if err := m.PhysicalCapacity.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("physicalCapacity")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("physicalCapacity")
			}
			return err
		}
	}

	return nil
}

func (m *Thresholds) contextValidateVdiskCapacity(ctx context.Context, formats strfmt.Registry) error {

	if m.VdiskCapacity != nil {

		if swag.IsZero(m.VdiskCapacity) { // not required
			return nil
		}

		if err := m.VdiskCapacity.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("vdiskCapacity")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("vdiskCapacity")
			}
			return err
		}
	}

	return nil
}

func (m *Thresholds) contextValidateVdiskLimit(ctx context.Context, formats strfmt.Registry) error {

	if m.VdiskLimit != nil {

		if swag.IsZero(m.VdiskLimit) { // not required
			return nil
		}

		if err := m.VdiskLimit.ContextValidate(ctx, formats); err != nil {
			if ve, ok := err.(*errors.Validation); ok {
				return ve.ValidateName("vdiskLimit")
			} else if ce, ok := err.(*errors.CompositeError); ok {
				return ce.ValidateName("vdiskLimit")
			}
			return err
		}
	}

	return nil
}

// MarshalBinary interface implementation
func (m *Thresholds) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *Thresholds) UnmarshalBinary(b []byte) error {
	var res Thresholds
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
